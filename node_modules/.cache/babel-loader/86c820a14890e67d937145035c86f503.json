{"ast":null,"code":"import { Utils } from \"../../../tools/utils\";\nimport Shape from \"./shape\";\nexport class Rectangle extends Shape {\n  setWidth(width) {\n    this.width = width;\n    return this;\n  }\n\n  setHeight(height) {\n    this.height = height;\n    return this;\n  }\n\n  getCenterPoint() {\n    let p = this.getPosition();\n    return [p[0] + this.width / 2, p[1] + this.height / 2];\n  }\n\n  getExternalPoint(angle, gap) {\n    let c = this.getCenterPoint();\n    let p = this.getPosition();\n    let rbc = Utils.getAngle(c[0], c[1], p[0] + this.width, p[1] + this.height); //right-bottom corner\n\n    let lbc = Math.PI - rbc; //left-bottom corner\n\n    let ltc = Math.PI + rbc; //left-top corner\n\n    let rtc = Utils._2PI - rbc; //right-top corner\n\n    angle = Utils.normalizeRadian(angle); //get angle between 0 - ~629\n\n    if (angle >= rbc && angle < lbc) {\n      //cross bottom edge\n      return this.getTBTarget(c, angle, gap, 1);\n    } else if (angle >= lbc && angle < ltc) {\n      //cross left edge\n      return this.getLRTarget(c, angle, gap, -1);\n    } else if (angle >= ltc && angle < rtc) {\n      //cross top edge\n      return this.getTBTarget(c, angle, gap, -1);\n    } else {\n      //cross right edge\n      return this.getLRTarget(c, angle, gap, 1);\n    }\n  }\n\n  getTBTarget(c, angle, gap, sign) {\n    let l = this.height / 2 / Math.sin(angle);\n    l += sign * gap;\n    return [c[0] + sign * l * Math.cos(angle), c[1] + sign * l * Math.sin(angle)];\n  }\n\n  getLRTarget(c, angle, gap, sign) {\n    let l = this.width / 2 / Math.cos(angle);\n    l += sign * gap;\n    return [c[0] + sign * l * Math.cos(angle), c[1] + sign * l * Math.sin(angle)];\n  }\n\n  render(canvasCtx) {\n    canvasCtx.beginPath();\n    let p = this.getPosition();\n    canvasCtx.rect(p[0], p[1], this.width, this.height);\n    canvasCtx.closePath();\n    super.render(canvasCtx);\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/simple/rectangle.js"],"names":["Utils","Shape","Rectangle","setWidth","width","setHeight","height","getCenterPoint","p","getPosition","getExternalPoint","angle","gap","c","rbc","getAngle","lbc","Math","PI","ltc","rtc","_2PI","normalizeRadian","getTBTarget","getLRTarget","sign","l","sin","cos","render","canvasCtx","beginPath","rect","closePath"],"mappings":"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","sourcesContent":["import {Utils} from \"../../../tools/utils\";\nimport Shape from \"./shape\";\n\nexport class Rectangle extends Shape {\n\n    setWidth(width) {\n        this.width = width;\n        return this;\n    }\n\n    setHeight(height) {\n        this.height = height;\n        return this;\n    }\n\n    getCenterPoint() {\n        let p = this.getPosition();\n        return [p[0] + this.width / 2, p[1] + this.height / 2]\n    }\n\n    getExternalPoint(angle, gap) {\n        let c = this.getCenterPoint();\n        let p = this.getPosition();\n        let rbc = Utils.getAngle(c[0], c[1], p[0] + this.width, p[1] + this.height);//right-bottom corner\n        let lbc = Math.PI - rbc;//left-bottom corner\n        let ltc = Math.PI + rbc;//left-top corner\n        let rtc = Utils._2PI - rbc;//right-top corner\n\n        angle = Utils.normalizeRadian(angle);//get angle between 0 - ~629\n\n        if (angle >= rbc && angle < lbc) {//cross bottom edge\n            return this.getTBTarget(c, angle, gap, 1);\n        } else if (angle >= lbc && angle < ltc) {//cross left edge\n            return this.getLRTarget(c, angle, gap, -1);\n        } else if (angle >= ltc && angle < rtc) {//cross top edge\n            return this.getTBTarget(c, angle, gap, -1);\n        } else {//cross right edge\n            return this.getLRTarget(c, angle, gap, 1);\n        }\n    }\n\n    getTBTarget(c, angle, gap, sign) {\n        let l = (this.height / 2) / Math.sin(angle);\n        l += sign * gap;\n        return [c[0] + sign * l * Math.cos(angle), c[1] + sign * l * Math.sin(angle)];\n    }\n\n    getLRTarget(c, angle, gap, sign) {\n        let l = (this.width / 2) / Math.cos(angle)\n        l += sign * gap;\n        return [c[0] + sign * l * Math.cos(angle), c[1] + sign * l * Math.sin(angle)];\n    }\n\n    render(canvasCtx) {\n        canvasCtx.beginPath();\n        let p = this.getPosition();\n        canvasCtx.rect(p[0], p[1], this.width, this.height);\n        canvasCtx.closePath();\n        super.render(canvasCtx);\n    }\n}"]},"metadata":{},"sourceType":"module"}