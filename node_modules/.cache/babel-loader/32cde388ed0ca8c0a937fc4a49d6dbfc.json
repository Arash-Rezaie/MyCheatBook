{"ast":null,"code":"import { Shape } from \"./shape\";\nimport { Utils } from \"../../../tools/utils\";\nimport { Text } from \"./text\";\nexport class Line extends Shape {\n  constructor() {\n    super();\n    this.processed = false;\n    this.setStrokeWidth(1);\n  }\n\n  setPosition(position) {\n    this.start = this.getPointObject(position);\n    return this;\n  }\n\n  setStart(point) {\n    return this.setPosition(point);\n  }\n\n  setEnd(point) {\n    this.end = this.getPointObject(point);\n    return this;\n  }\n\n  setQuadraticPoint(point) {\n    this.qCurve = this.getPointObject(point);\n    return this;\n  }\n  /**\n   * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n   */\n\n\n  getPointObject(point) {\n    let ans = {};\n\n    switch (this.getTypeOf(point)) {\n      case \"number,number\":\n        //[x,y]\n        ans[\"xy\"] = point;\n        break;\n\n      case \"string,number\":\n        //[intR,length] or [intD,length]\n        let i = point[0].length - 1;\n        let c = point[0][i];\n        let v = Number(point[0].substring(0, i));\n\n        if (c === 'R' || c === 'r') {\n          ans[\"angle\"] = Utils.normalizeRadian(v);\n          ans[\"gap\"] = point[1];\n        } else if (c === 'D' || c === 'd') {\n          ans[\"angle\"] = Utils.normalizeRadian(Utils.deg2Rad(v));\n          ans[\"gap\"] = point[1];\n        } else {\n          throw new Error('wrong input');\n        }\n\n        break;\n\n      case \"object,number\":\n        //[shape,gap]\n        ans[\"shape\"] = point[0];\n        ans[\"gap\"] = point[1];\n        break;\n\n      default:\n        throw new Error('wrong input');\n    }\n\n    return ans;\n  }\n\n  getTypeOf(point) {\n    return typeof point[0] + ',' + typeof point[1];\n  }\n\n  render(canvasCtx) {\n    this.preparePoints();\n    canvasCtx.beginPath();\n    canvasCtx.fillStyle = 'transparent';\n    canvasCtx.moveTo(this.start[\"xy\"][0], this.start[\"xy\"][1]);\n    if (this.qCurve) canvasCtx.quadraticCurveTo(this.qCurve[\"xy\"][0], this.qCurve[\"xy\"][1], this.end[\"xy\"][0], this.end[\"xy\"][1]);else canvasCtx.lineTo(this.end[\"xy\"][0], this.end[\"xy\"][1]); // canvasCtx.closePath();\n\n    this.fillColor2 = this.fillColor;\n    this.fillColor = undefined;\n    super.render(canvasCtx);\n    this.fillColor = this.fillColor2;\n\n    if (this.direction !== undefined && this.places !== undefined) {\n      let p1 = this.start[\"xy\"];\n      let p2 = this.end[\"xy\"];\n      this.prepareForArrow(p1, p2);\n      let angle = this.direction ? this.start[\"connAngle\"] : this.end[\"connAngle\"];\n      let loc, x, y;\n\n      for (let i = 0; i < this.places.length; i++) {\n        loc = this.places[i];\n        x = p1[0] + (p2[0] - p1[0]) * loc;\n        y = p1[1] + (p2[1] - p1[1]) * loc;\n        this.drawArrow(canvasCtx, 10, angle, x, y);\n      }\n    }\n  }\n\n  preparePoints() {\n    if (!this.processed) {\n      if (this.qCurve != null) {\n        if (this.qCurve[\"shape\"] != null) {\n          this.process2PointsXY(this.qCurve, this.start, true);\n          this.process2PointsXY(this.end[\"shape\"] != null ? this.qCurve : this.start, this.end, true);\n          this.processCurveAsShape(this.start, this.qCurve, this.end); //pick an accurate point for curve\n        } else {\n          this.process2PointsXY(this.start, this.qCurve);\n          this.process2PointsXY(this.start, this.end);\n        }\n      } else {\n        this.process2PointsXY(this.start, this.end);\n      }\n\n      this.processed = true;\n    }\n  }\n\n  process2PointsXY(p1, p2, ignoreP1XYModification = false) {\n    let c1;\n\n    if (p2[\"xy\"] == null) {\n      if (p2[\"angle\"] != null) {\n        let angle = p2[\"angle\"];\n        p2[\"xy\"] = Utils.getPointByAngle(this.getTargetXY(p1, angle), angle, p2[\"gap\"]);\n      } else if (p2[\"shape\"] != null) {\n        c1 = this.getPointCenter(p1);\n        let c2 = p2[\"shape\"].getCenterPoint();\n        let angle = Utils.getAngle(c2[0], c2[1], c1[0], c1[1]); //angle from p2 to p1\n\n        p2[\"xy\"] = this.getTargetXY(p2, angle);\n      } else {\n        throw new Error(\"no way to calculate point.xy\");\n      }\n    }\n\n    if (!ignoreP1XYModification && p1[\"xy\"] == null) {\n      if (c1 == null) c1 = this.getPointCenter(p1);\n      let angle = Utils.getAngleByPoint(c1, p2[\"xy\"]);\n      p1[\"xy\"] = this.getTargetXY(p1, angle);\n    }\n  }\n\n  getPointCenter(p) {\n    if (p[\"xy\"]) {\n      return p[\"xy\"];\n    } else if (p[\"shape\"] != null) {\n      return p[\"shape\"].getCenterPoint();\n    } else {\n      throw new Error(\"p1 is not acceptable. It must be a point or a shape\");\n    }\n  }\n\n  processCurveAsShape(start, curve, end) {\n    let t = this.qCurve[\"shape\"].getCenterPoint();\n    let angle1 = Utils.getAngleByPoint(t, start[\"xy\"]);\n    let angle2 = Utils.getAngleByPoint(t, end[\"xy\"]);\n    curve[\"xy\"] = this.getTargetXY(curve[\"shape\"], this.getMidAngle(angle1, angle2));\n  }\n\n  getMidAngle(angle1, angle2) {\n    let midAngle = (angle1 + angle2) / 2;\n    if (Math.abs(angle1 - angle2) > Math.PI) //if angle1 - angle3 > 180deg => correct mid angle\n      midAngle = Utils.reverseRad(midAngle);\n    let d1 = Utils.rad2Deg(angle1);\n    let d2 = Utils.rad2Deg(angle2);\n    let d3 = Utils.rad2Deg(midAngle);\n    return midAngle;\n  } //p must be a shape\n\n\n  getTargetXY(p, angle) {\n    return p[\"xy\"] != null ? p[\"xy\"] : p[\"shape\"][\"getExternalPoint\"] != null ? p[\"shape\"].getExternalPoint(angle, p[\"gap\"]) : Utils.getPointByAngle(p[\"shape\"].getCenterPoint(), angle, p[\"gap\"]);\n  }\n\n  getCenterPoint() {\n    this.preparePoints();\n    return [(this.start[0] + this.end[0]) / 2, (this.start[1] + this.end[1]) / 2];\n  }\n  /**\n   * show arrows on the line\n   * @param direction 0 or 1\n   * @param places array of float values, each is 0 - 1;\n   * @return Shape\n   */\n\n\n  showArrow(direction, places) {\n    this.direction = direction;\n    this.places = places;\n    return this;\n  }\n\n  drawArrow(canvasCtx, length, angle, x, y) {\n    canvasCtx.beginPath();\n    let p1 = [x + length * Math.cos(angle - Utils._PI6), y + length * Math.sin(angle - Utils._PI6)];\n    let p2 = [x + length * Math.cos(angle + Utils._PI6), y + length * Math.sin(angle + Utils._PI6)];\n    canvasCtx.moveTo(x, y);\n    canvasCtx.lineTo(p1[0], p1[1]);\n    canvasCtx.lineTo(p2[0], p2[1]);\n    canvasCtx.closePath();\n    super.render(canvasCtx);\n  }\n\n  prepareForArrow(pStart, pEnd) {\n    if (typeof this.places === 'number') this.places = [this.places];\n\n    if (this.qCurve != null) {\n      this.places = this.shrinkTo01(this.places);\n      let pCurve = this.qCurve[\"xy\"];\n      debugger;\n      let m = this.getMidAngle(Utils.reverseRad(Utils.getAngleByPoint(pStart, pCurve)), Utils.reverseRad(Utils.getAngleByPoint(pEnd, pCurve)));\n      m = Math.atan(m);\n      let l1 = this.getLineFormula(pCurve, m);\n      let l2 = this.getLineFormula(pStart, (pStart[1] - pEnd[1]) / (pStart[0] - pEnd[0]));\n      let y = (l1[2] - l2[2]) / (l1[1] - l2[1]);\n      let x = -l1[2] - l1[1] * y;\n      let intersectPoint = [x, y]; // let c = l1[0] * l2[1] - l2[0] * l1[1];\n      // let intersectPoint = [(l1[1] * l2[2] - l2[1] * l1[2]) / c, (l2[0] * l1[2] - l1[0] * l2[2]) / c];\n\n      Utils.db.addShape(new Line().setStart(pCurve).setEnd(intersectPoint).setStrokeColor('red')).addShape(new Line().setStart(pStart).setEnd(pEnd).setStrokeColor('red')).resumeRender();\n    } else {\n      this.start[\"connAngle\"] = Utils.getAngleByPoint(pStart, pEnd);\n      this.start[\"connAngle\"] = Utils.reverseRad(this.start[\"connAngle\"]);\n    }\n\n    this.length = Math.sqrt(Math.pow(Math.abs(pStart[0] - pEnd[0]), 2) + Math.pow(Math.abs(pStart[1] - pEnd[1]), 2));\n  } // return ax + by + c = 0\n\n\n  getLineFormula(p, m) {\n    return [1, -m, m * p[1] - p[0]];\n  }\n\n  shrinkTo01(a) {\n    let ans = [];\n    a.forEach(v => v <= 0.5 ? ans[0] = 0 : ans[1] = 1);\n    return ans[0] != null ? ans : [1];\n  }\n\n}\nexport class HLine extends Line {\n  setLength(l) {\n    l > 0 ? this.lineTo(['0D', l]) : this.lineTo(['180D', -l]);\n    return this;\n  }\n\n}\nexport class VLine extends Line {\n  setLength(l) {\n    l > 0 ? this.lineTo(['90D', l]) : this.lineTo(['270D', -l]);\n    return this;\n  }\n\n}\nexport class Vector extends Line {\n  constructor() {\n    super();\n    this.setStrokeColor('black').setFillColor('black').setStrokeWidth(2).showArrow(1, 1);\n  }\n\n}\nexport class HVector extends Vector {\n  setLabel(label) {\n    if (typeof label === 'string') label = new Text().setPosition(this.getCenterPoint()).setLabel(label).setOffset([0, -6]).setFontStyle('');\n    return super.setLabel(label);\n  }\n\n  setLength(l) {\n    return l > 0 ? this.lineTo(['0D', l]) : this.lineTo(['180D', -l]);\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/simple/line.js"],"names":["Shape","Utils","Text","Line","constructor","processed","setStrokeWidth","setPosition","position","start","getPointObject","setStart","point","setEnd","end","setQuadraticPoint","qCurve","ans","getTypeOf","i","length","c","v","Number","substring","normalizeRadian","deg2Rad","Error","render","canvasCtx","preparePoints","beginPath","fillStyle","moveTo","quadraticCurveTo","lineTo","fillColor2","fillColor","undefined","direction","places","p1","p2","prepareForArrow","angle","loc","x","y","drawArrow","process2PointsXY","processCurveAsShape","ignoreP1XYModification","c1","getPointByAngle","getTargetXY","getPointCenter","c2","getCenterPoint","getAngle","getAngleByPoint","p","curve","t","angle1","angle2","getMidAngle","midAngle","Math","abs","PI","reverseRad","d1","rad2Deg","d2","d3","getExternalPoint","showArrow","cos","_PI6","sin","closePath","pStart","pEnd","shrinkTo01","pCurve","m","atan","l1","getLineFormula","l2","intersectPoint","db","addShape","setStrokeColor","resumeRender","sqrt","pow","a","forEach","HLine","setLength","l","VLine","Vector","setFillColor","HVector","setLabel","label","setOffset","setFontStyle"],"mappings":"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","sourcesContent":["import {Shape} from \"./shape\";\nimport {Utils} from \"../../../tools/utils\";\nimport {Text} from \"./text\";\n\nexport class Line extends Shape {\n    start;\n    end;\n    qCurve;\n    processed = false;\n\n    constructor() {\n        super();\n        this.setStrokeWidth(1);\n    }\n\n    setPosition(position) {\n        this.start = this.getPointObject(position);\n        return this;\n    }\n\n    setStart(point) {\n        return this.setPosition(point);\n    }\n\n    setEnd(point) {\n        this.end = this.getPointObject(point);\n        return this;\n    }\n\n    setQuadraticPoint(point) {\n        this.qCurve = this.getPointObject(point);\n        return this;\n    }\n\n    /**\n     * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n     */\n    getPointObject(point) {\n        let ans = {};\n        switch (this.getTypeOf(point)) {\n            case \"number,number\"://[x,y]\n                ans[\"xy\"] = point;\n                break;\n            case \"string,number\"://[intR,length] or [intD,length]\n                let i = point[0].length - 1;\n                let c = point[0][i];\n                let v = Number(point[0].substring(0, i));\n                if (c === 'R' || c === 'r') {\n                    ans[\"angle\"] = Utils.normalizeRadian(v);\n                    ans[\"gap\"] = point[1];\n                } else if (c === 'D' || c === 'd') {\n                    ans[\"angle\"] = Utils.normalizeRadian(Utils.deg2Rad(v));\n                    ans[\"gap\"] = point[1];\n                } else {\n                    throw new Error('wrong input');\n                }\n                break;\n            case \"object,number\"://[shape,gap]\n                ans[\"shape\"] = point[0];\n                ans[\"gap\"] = point[1];\n                break;\n            default:\n                throw new Error('wrong input');\n        }\n        return ans;\n    }\n\n    getTypeOf(point) {\n        return typeof point[0] + ',' + typeof point[1]\n    }\n\n    render(canvasCtx) {\n        this.preparePoints();\n        canvasCtx.beginPath();\n        canvasCtx.fillStyle = 'transparent';\n        canvasCtx.moveTo(this.start[\"xy\"][0], this.start[\"xy\"][1]);\n        if (this.qCurve)\n            canvasCtx.quadraticCurveTo(this.qCurve[\"xy\"][0], this.qCurve[\"xy\"][1], this.end[\"xy\"][0], this.end[\"xy\"][1]);\n        else\n            canvasCtx.lineTo(this.end[\"xy\"][0], this.end[\"xy\"][1]);\n        // canvasCtx.closePath();\n        this.fillColor2 = this.fillColor;\n        this.fillColor = undefined;\n        super.render(canvasCtx);\n        this.fillColor = this.fillColor2;\n        if (this.direction !== undefined && this.places !== undefined) {\n            let p1 = this.start[\"xy\"];\n            let p2 = this.end[\"xy\"];\n            this.prepareForArrow(p1, p2);\n            let angle = this.direction ? this.start[\"connAngle\"] : this.end[\"connAngle\"];\n            let loc, x, y;\n            for (let i = 0; i < this.places.length; i++) {\n                loc = this.places[i];\n                x = p1[0] + (p2[0] - p1[0]) * loc;\n                y = p1[1] + (p2[1] - p1[1]) * loc;\n                this.drawArrow(canvasCtx, 10, angle, x, y);\n            }\n        }\n    }\n\n    preparePoints() {\n        if (!this.processed) {\n            if (this.qCurve != null) {\n                if (this.qCurve[\"shape\"] != null) {\n                    this.process2PointsXY(this.qCurve, this.start, true);\n                    this.process2PointsXY((this.end[\"shape\"] != null ? this.qCurve : this.start), this.end, true);\n                    this.processCurveAsShape(this.start, this.qCurve, this.end);//pick an accurate point for curve\n                } else {\n                    this.process2PointsXY(this.start, this.qCurve);\n                    this.process2PointsXY(this.start, this.end);\n                }\n            } else {\n                this.process2PointsXY(this.start, this.end);\n            }\n            this.processed = true;\n        }\n    }\n\n    process2PointsXY(p1, p2, ignoreP1XYModification = false) {\n        let c1;\n        if (p2[\"xy\"] == null) {\n            if (p2[\"angle\"] != null) {\n                let angle = p2[\"angle\"];\n                p2[\"xy\"] = Utils.getPointByAngle(this.getTargetXY(p1, angle), angle, p2[\"gap\"]);\n            } else if (p2[\"shape\"] != null) {\n                c1 = this.getPointCenter(p1);\n                let c2 = p2[\"shape\"].getCenterPoint();\n                let angle = Utils.getAngle(c2[0], c2[1], c1[0], c1[1]);//angle from p2 to p1\n                p2[\"xy\"] = this.getTargetXY(p2, angle);\n            } else {\n                throw new Error(\"no way to calculate point.xy\");\n            }\n        }\n\n        if (!ignoreP1XYModification && p1[\"xy\"] == null) {\n            if (c1 == null)\n                c1 = this.getPointCenter(p1);\n            let angle = Utils.getAngleByPoint(c1, p2[\"xy\"]);\n            p1[\"xy\"] = this.getTargetXY(p1, angle);\n        }\n    }\n\n    getPointCenter(p) {\n        if (p[\"xy\"]) {\n            return p[\"xy\"];\n        } else if (p[\"shape\"] != null) {\n            return p[\"shape\"].getCenterPoint();\n        } else {\n            throw new Error(\"p1 is not acceptable. It must be a point or a shape\")\n        }\n    }\n\n    processCurveAsShape(start, curve, end) {\n        let t = this.qCurve[\"shape\"].getCenterPoint();\n        let angle1 = Utils.getAngleByPoint(t, start[\"xy\"]);\n        let angle2 = Utils.getAngleByPoint(t, end[\"xy\"]);\n        curve[\"xy\"] = this.getTargetXY(curve[\"shape\"], this.getMidAngle(angle1, angle2));\n    }\n\n    getMidAngle(angle1, angle2) {\n        let midAngle = (angle1 + angle2) / 2;\n        if (Math.abs(angle1 - angle2) > Math.PI) //if angle1 - angle3 > 180deg => correct mid angle\n            midAngle = Utils.reverseRad(midAngle);\n\n        let d1 = Utils.rad2Deg(angle1);\n        let d2 = Utils.rad2Deg(angle2);\n        let d3 = Utils.rad2Deg(midAngle);\n\n        return midAngle;\n    }\n\n    //p must be a shape\n    getTargetXY(p, angle) {\n        return (p[\"xy\"] != null) ?\n            p[\"xy\"] :\n            (\n                (p[\"shape\"][\"getExternalPoint\"] != null) ?\n                    p[\"shape\"].getExternalPoint(angle, p[\"gap\"]) :\n                    Utils.getPointByAngle(p[\"shape\"].getCenterPoint(), angle, p[\"gap\"])\n            )\n    }\n\n    getCenterPoint() {\n        this.preparePoints();\n        return [(this.start[0] + this.end[0]) / 2, (this.start[1] + this.end[1]) / 2]\n    }\n\n    /**\n     * show arrows on the line\n     * @param direction 0 or 1\n     * @param places array of float values, each is 0 - 1;\n     * @return Shape\n     */\n    showArrow(direction, places) {\n        this.direction = direction;\n        this.places = places;\n        return this;\n    }\n\n    drawArrow(canvasCtx, length, angle, x, y) {\n        canvasCtx.beginPath();\n        let p1 = [x + length * Math.cos(angle - Utils._PI6), y + length * Math.sin(angle - Utils._PI6)];\n        let p2 = [x + length * Math.cos(angle + Utils._PI6), y + length * Math.sin(angle + Utils._PI6)];\n        canvasCtx.moveTo(x, y);\n        canvasCtx.lineTo(p1[0], p1[1]);\n        canvasCtx.lineTo(p2[0], p2[1]);\n        canvasCtx.closePath();\n        super.render(canvasCtx);\n    }\n\n    prepareForArrow(pStart, pEnd) {\n        if (typeof this.places === 'number')\n            this.places = [this.places];\n\n        if (this.qCurve != null) {\n            this.places = this.shrinkTo01(this.places);\n            let pCurve = this.qCurve[\"xy\"];\n            debugger\n            let m = this.getMidAngle(\n                Utils.reverseRad(Utils.getAngleByPoint(pStart, pCurve)),\n                Utils.reverseRad(Utils.getAngleByPoint(pEnd, pCurve)));\n            m = Math.atan(m);\n            let l1 = this.getLineFormula(pCurve, m);\n            let l2 = this.getLineFormula(pStart, (pStart[1] - pEnd[1]) / (pStart[0] - pEnd[0]));\n            let y = (l1[2] - l2[2]) / (l1[1] - l2[1]);\n            let x = -l1[2] - (l1[1] * y);\n            let intersectPoint = [x, y];\n            // let c = l1[0] * l2[1] - l2[0] * l1[1];\n            // let intersectPoint = [(l1[1] * l2[2] - l2[1] * l1[2]) / c, (l2[0] * l1[2] - l1[0] * l2[2]) / c];\n            Utils.db\n                .addShape(\n                    new Line()\n                        .setStart(pCurve)\n                        .setEnd(intersectPoint)\n                        .setStrokeColor('red')\n                )\n                .addShape(\n                    new Line()\n                        .setStart(pStart)\n                        .setEnd(pEnd)\n                        .setStrokeColor('red')\n                )\n                .resumeRender();\n\n        } else {\n            this.start[\"connAngle\"] = Utils.getAngleByPoint(pStart, pEnd);\n            this.start[\"connAngle\"] = Utils.reverseRad(this.start[\"connAngle\"]);\n        }\n        this.length = Math.sqrt(Math.pow(Math.abs(pStart[0] - pEnd[0]), 2) + Math.pow(Math.abs(pStart[1] - pEnd[1]), 2));\n    }\n\n    // return ax + by + c = 0\n    getLineFormula(p, m) {\n        return [1, -m, m * p[1] - p[0]];\n    }\n\n    shrinkTo01(a) {\n        let ans = [];\n        a.forEach(v => v <= 0.5 ? ans[0] = 0 : ans[1] = 1);\n        return ans[0] != null ? ans : [1];\n    }\n}\n\nexport class HLine\n    extends Line {\n    setLength(l) {\n        l > 0 ?\n            this.lineTo(['0D', l]) :\n            this.lineTo(['180D', -l])\n        return this;\n    }\n}\n\nexport class VLine extends Line {\n    setLength(l) {\n        l > 0 ?\n            this.lineTo(['90D', l]) :\n            this.lineTo(['270D', -l])\n        return this;\n    }\n}\n\nexport class Vector extends Line {\n    constructor() {\n        super();\n        this.setStrokeColor('black')\n            .setFillColor('black')\n            .setStrokeWidth(2)\n            .showArrow(1, 1);\n    }\n}\n\nexport class HVector extends Vector {\n    setLabel(label) {\n        if (typeof label === 'string')\n            label = new Text()\n                .setPosition(this.getCenterPoint())\n                .setLabel(label)\n                .setOffset([0, -6])\n                .setFontStyle('');\n        return super.setLabel(label);\n    }\n\n    setLength(l) {\n        return (l > 0) ?\n            this.lineTo(['0D', l]) :\n            this.lineTo(['180D', -l])\n    }\n}"]},"metadata":{},"sourceType":"module"}