{"ast":null,"code":"import { Shape } from \"./shape\";\nimport { Utils } from \"../../../tools/utils\";\nimport { Text } from \"./text\"; // export class Line extends Shape {\n//     path = [];\n//\n//     constructor() {\n//         super();\n//         this.setStrokeWidth(1);\n//     }\n//\n//     setPosition(position) {\n//         return this.addPoint(position, 0);\n//     }\n//\n//     addPoint(point, index = null) {\n//         if (index == null) {\n//             this.path.push(this.getPoint(point));\n//         } else {\n//             for (let i = this.path.length; i > index; i--)\n//                 this.path[i] = this.path[i - 1];\n//             this.path[index] = this.getPoint(point);\n//         }\n//         return this;\n//     }\n//\n//     /**\n//      * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n//      * you can have m & n before point location to make the line curvy:<br/>\n//      * ex.<br/>\n//      * [4, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [4, 5] in curvy shape<br/>\n//      * [90d, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [90d, 5] in curvy shape<br/>\n//      * [1r, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [1r, 5] in curvy shape<br/>\n//      * [shape, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [shape, 5] in curvy shape<br/>\n//      *\n//      */\n//     getPoint(point) {\n//         let ans = {};\n//         let p, c;\n//         if (point[2] != null && point[3] != null) {\n//             p = [point[2], point[3]];\n//             c = [point[0], point[1]];\n//         } else {\n//             p = [point[0], point[1]];\n//         }\n//         switch (this.getTypeOf(p)) {\n//             case \"number,number\"://[x,y]\n//                 ans[\"xy\"] = p;\n//                 break;\n//             case \"string,number\"://[intR,length] or [intD,length]\n//                 let i = p[0].length - 1;\n//                 let c = p[0][i];\n//                 let v = Number(p[0].substring(0, i));\n//                 if (c === 'R' || c === 'r') {\n//                     ans[\"angle\"] = Utils.normalizeRadian(v);\n//                     ans[\"gap\"] = p[1];\n//                 } else if (c === 'D' || c === 'd') {\n//                     ans[\"angle\"] = Utils.normalizeRadian(Utils.deg2Rad(v));\n//                     ans[\"gap\"] = p[1];\n//                 } else {\n//                     throw new Error('wrong input');\n//                 }\n//                 break;\n//             case \"object,number\"://[shape,gap]\n//                 ans[\"shape\"] = p[0];\n//                 ans[\"gap\"] = p[1];\n//                 break;\n//             default:\n//                 throw new Error('wrong input');\n//         }\n//         if (c != null) {\n//             ans[\"curve\"] = this.getPoint(c);\n//         }\n//         return ans;\n//     }\n//\n//     getTypeOf(point) {\n//         return typeof point[0] + ',' + typeof point[1]\n//     }\n//\n//     render(canvasCtx) {\n//         this.preparePoints();\n//         canvasCtx.beginPath();\n//         let p = this.path[0];\n//         canvasCtx.moveTo(p[\"xy\"][0], p[\"xy\"][1]);\n//         for (let i = 1; i < this.path.length; i++) {\n//             p = this.path[i];\n//             if (p[\"curve\"] != null)\n//                 canvasCtx.quadraticCurveTo(p[\"curve\"][\"xy\"][0], p[\"curve\"][\"xy\"][1], p[\"xy\"][0], p[\"xy\"][1]);\n//             else\n//                 canvasCtx.lineTo(p[\"xy\"][0], p[\"xy\"][1]);\n//         }\n//         // canvasCtx.closePath();\n//         super.render(canvasCtx);\n//     }\n//\n//     preparePoints() {\n//         debugger\n//         for (let i = 1; i < this.path.length; i++) {\n//             if (this.path[i][\"curve\"] != null)\n//                 this.process3PointsXY(this.path[i - 1], this.path[\"curve\"], this.path[i])\n//             else\n//                 this.process2PointsXY(this.path[i - 1], this.path[i])\n//         }\n//     }\n//\n//     process2PointsXY(p1, p2, ignoreP1XYModification = false) {\n//         let angle;\n//         if (p2[\"xy\"] == null) {\n//             let c1 = p1[\"xy\"] != null ? p1[\"xy\"] : p1[\"shape\"].getCenterPoint();\n//             if (p2[\"angle\"] != null) {\n//                 angle = p2[\"angle\"];\n//                 p2[\"xy\"] = Utils.getPointByAngle(c1, angle, p2[\"gap\"]);\n//             } else if (p2[\"shape\"] != null) {\n//                 let c2 = p2[\"shape\"].getCenterPoint();\n//                 angle = Utils.getAngle(c2[0], c2[1], c1[0], c1[1]);\n//                 p2[\"xy\"] = this.getTargetXY(p2, angle);\n//             } else {\n//                 throw new Error(\"no way to calculate point.xy\");\n//             }\n//         }\n//\n//         if (!ignoreP1XYModification && p1[\"xy\"] == null) {\n//             p1[\"xy\"] = this.getTargetXY(p1, Math.PI - angle)\n//         }\n//     }\n//\n//     //p must be a shape\n//     getTargetXY(p, angle) {\n//         return (p[\"shape\"][\"getExternalPoint\"] != null) ?\n//             p[\"shape\"].getExternalPoint(angle, p[\"gap\"]) :\n//             Utils.getPointByAngle(p[\"shape\"].getCenterPoint(), angle, p[\"gap\"])\n//     }\n//\n//     process3PointsXY(p1, p2, p3) {\n//         if (p3[\"xy\"] == null) {\n//             if (p3[\"shape\"] != null) {\n//                 this.process2PointsXY(p2, p3, true);\n//             } else if (p3[\"angle\"] != null) {\n//                 this.process2PointsXY(p1, p3, true);\n//             } else {\n//                 throw new Error(\"no way to calculate point.xy\");\n//             }\n//         }\n//\n//         if (p2[\"xy\"] == null) {\n//             if (p2[\"angle\"] != null) {\n//                 p2[\"xy\"] = Utils.getPointByAngle(p1[\"xy\"], p2[\"angle\"], p2[\"gap\"]);\n//                 this.process2PointsXY(p2, p1, true);\n//             } else if (p2[\"shape\"] != null) {\n//                 //as p2 is a shape, p2[\"xy\"] can vary by angle between 2 other shape, so lets use an angle in the middle of that 2\n//                 this.process2PointsXY(p2, p1, true);\n//                 let c2 = p2[\"shape\"].getCenterPoint();\n//                 let angle1 = Utils.getAngle(c2[0], c2[1], p1[\"xy\"][0], p1[\"xy\"][1]);\n//                 let angle3 = Utils.getAngle(c2[0], c2[1], p3[\"xy\"][0], p3[\"xy\"][1]);\n//                 let angle2 = (angle1 + angle3) / 2;\n//\n//                 //if angle1 - angle3 > 180deg => correct mid angle\n//                 if (Math.abs(angle1 - angle3) > Math.PI)\n//                     angle2 -= Math.PI;\n//                 p2[\"xy\"] = this.getTargetXY(p2, angle2);\n//             } else {\n//                 throw new Error(\"no way to calculate point.xy\");\n//             }\n//         }\n//     }\n//\n//     // getNeighbourPoint(point) {\n//     //     let index;\n//     //     for (index = 0; index < this.path.length; index++) if (this.path[index] === point) break\n//     //     return index === 0 ? this.path[1] : this.path[index - 1];\n//     // }\n//     //\n//     // /**\n//     //  * @param shape1 shape 1\n//     //  * @param shape2 shape 2\n//     //  * @param gap the gap between line and target shapes. gap>=0\n//     //  */\n//     // between(shape1, shape2, gap = 0) {\n//     //     let c1 = shape1.getCenterPoint();\n//     //     let c2 = shape2.getCenterPoint();\n//     //     c1 = shape1.getExternalPoint(Utils.getAngle(c1[0], c1[1], c2[0], c2[1]), gap);\n//     //     c2 = shape2.getExternalPoint(Utils.getAngle(c2[0], c2[1], c1[0], c1[1]), gap);\n//     //     this.setPosition(c1);\n//     //     this.lineTo(c2);\n//     //     return this;\n//     // }\n//     //\n//     // /**\n//     //  * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or shape\n//     //  */\n//     // lineTo(point) {\n//     //     if (typeof point[0] === 'string') {\n//     //         let i = point[0].length - 1;\n//     //         let c = point[0][i];\n//     //         let v = Number(point[0].substring(0, i));\n//     //         if (c === 'R' || c === 'r') {\n//     //             this.secondP = this.getTargetPoint(v, point[1]);\n//     //         } else if (c === 'D' || c === 'd') {\n//     //             this.secondP = this.getTargetPoint(Utils.deg2Rad(v), point[1]);\n//     //         } else {\n//     //             throw new Error('wrong input');\n//     //         }\n//     //     } else {\n//     //         this.secondP = point;\n//     //     }\n//     //     return this;\n//     // }\n//     //\n//     // getTargetPoint(r, d) {\n//     //     let p = this.getPosition();\n//     //     return [p[0] + Math.cos(r) * d, p[1] + Math.sin(r) * d];\n//     // }\n//\n//     getCenterPoint() {\n//         let p = this.getPosition();\n//         return [(p[0] + this.secondP[0]) / 2, (p[1] + this.secondP[1]) / 2]\n//     }\n//\n//     /**\n//      * show arrows on the line\n//      * @param direction 0 or 1\n//      * @param places array of float values, each is 0 - 1;\n//      * @return Shape\n//      */\n//     showArrow(direction, places) {\n//         this.direction = direction;\n//         this.places = places;\n//         return this;\n//     }\n//\n//     drawArrow(canvasCtx, length, angle, x, y) {\n//         canvasCtx.beginPath();\n//         let p1 = [x + length * Math.cos(angle - Utils._PI6), y + length * Math.sin(angle - Utils._PI6)];\n//         let p2 = [x + length * Math.cos(angle + Utils._PI6), y + length * Math.sin(angle + Utils._PI6)];\n//         canvasCtx.moveTo(x, y);\n//         canvasCtx.lineTo(p1[0], p1[1]);\n//         canvasCtx.lineTo(p2[0], p2[1]);\n//         canvasCtx.closePath();\n//         super.render(canvasCtx);\n//     }\n//\n//     // render(canvasCtx) {\n//     //     let p1 = this.getPosition();\n//     //     canvasCtx.beginPath();\n//     //     canvasCtx.moveTo(p1[0], p1[1]);\n//     //     canvasCtx.lineTo(this.secondP[0], this.secondP[1]);\n//     //     canvasCtx.closePath();\n//     //     super.render(canvasCtx);\n//     //     if (this.direction !== undefined && this.places !== undefined) {\n//     //         if (!this.places[0])\n//     //             this.places = [this.places];\n//     //         let angle = this.direction ? Utils.getAngle(this.secondP[0], this.secondP[1], p1[0], p1[1]) : Utils.getAngle(p1[0], p1[1], this.secondP[0], this.secondP[1]);\n//     //         for (let i = 0; i < this.places.length; i++) {\n//     //             let x = p1[0] + (this.secondP[0] - p1[0]) * this.places[i];\n//     //             let y = p1[1] + (this.secondP[1] - p1[1]) * this.places[i];\n//     //             this.drawArrow(canvasCtx, 10, angle, x, y);\n//     //         }\n//     //     }\n//     // }\n// }\n\nexport class Line extends Shape {\n  constructor() {\n    super();\n    this.setStrokeWidth(1);\n  }\n\n  setPosition(position) {\n    this.start = position;\n    return this;\n  }\n\n  setStart(point) {\n    return this.setPosition(point);\n  }\n\n  lineTo(point) {\n    this.end = point;\n    return this;\n  }\n\n  setQuadraticPoint(point) {\n    this.qCurve = point;\n    return this;\n  }\n\n  render(canvasCtx) {\n    this.preparePoints();\n    canvasCtx.beginPath();\n    canvasCtx.moveTo(this.start);\n    if (this.qCurve) canvasCtx.quadraticCurveTo(this.qCurve[0], this.qCurve[1], this.end[0], this.end[1]);else canvasCtx.lineTo(this.end[0], this.end[1]); // canvasCtx.closePath();\n\n    super.render(canvasCtx);\n  }\n\n  addPoint(point, index = null) {\n    if (index == null) {\n      this.path.push(this.getPoint(point));\n    } else {\n      for (let i = this.path.length; i > index; i--) this.path[i] = this.path[i - 1];\n\n      this.path[index] = this.getPoint(point);\n    }\n\n    return this;\n  }\n  /**\n   * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n   * you can have m & n before point location to make the line curvy:<br/>\n   * ex.<br/>\n   * [4, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [4, 5] in curvy shape<br/>\n   * [90d, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [90d, 5] in curvy shape<br/>\n   * [1r, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [1r, 5] in curvy shape<br/>\n   * [shape, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [shape, 5] in curvy shape<br/>\n   *\n   */\n\n\n  getPoint(point) {\n    let ans = {};\n    let p, c;\n\n    if (point[2] != null && point[3] != null) {\n      p = [point[2], point[3]];\n      c = [point[0], point[1]];\n    } else {\n      p = [point[0], point[1]];\n    }\n\n    switch (this.getTypeOf(p)) {\n      case \"number,number\":\n        //[x,y]\n        ans[\"xy\"] = p;\n        break;\n\n      case \"string,number\":\n        //[intR,length] or [intD,length]\n        let i = p[0].length - 1;\n        let c = p[0][i];\n        let v = Number(p[0].substring(0, i));\n\n        if (c === 'R' || c === 'r') {\n          ans[\"angle\"] = Utils.normalizeRadian(v);\n          ans[\"gap\"] = p[1];\n        } else if (c === 'D' || c === 'd') {\n          ans[\"angle\"] = Utils.normalizeRadian(Utils.deg2Rad(v));\n          ans[\"gap\"] = p[1];\n        } else {\n          throw new Error('wrong input');\n        }\n\n        break;\n\n      case \"object,number\":\n        //[shape,gap]\n        ans[\"shape\"] = p[0];\n        ans[\"gap\"] = p[1];\n        break;\n\n      default:\n        throw new Error('wrong input');\n    }\n\n    if (c != null) {\n      ans[\"curve\"] = this.getPoint(c);\n    }\n\n    return ans;\n  }\n\n  getTypeOf(point) {\n    return typeof point[0] + ',' + typeof point[1];\n  }\n\n  preparePoints() {\n    debugger;\n\n    for (let i = 1; i < this.path.length; i++) {\n      if (this.path[i][\"curve\"] != null) this.process3PointsXY(this.path[i - 1], this.path[\"curve\"], this.path[i]);else this.process2PointsXY(this.path[i - 1], this.path[i]);\n    }\n  }\n\n  process2PointsXY(p1, p2, ignoreP1XYModification = false) {\n    let angle;\n\n    if (p2[\"xy\"] == null) {\n      let c1 = p1[\"xy\"] != null ? p1[\"xy\"] : p1[\"shape\"].getCenterPoint();\n\n      if (p2[\"angle\"] != null) {\n        angle = p2[\"angle\"];\n        p2[\"xy\"] = Utils.getPointByAngle(c1, angle, p2[\"gap\"]);\n      } else if (p2[\"shape\"] != null) {\n        let c2 = p2[\"shape\"].getCenterPoint();\n        angle = Utils.getAngle(c2[0], c2[1], c1[0], c1[1]);\n        p2[\"xy\"] = this.getTargetXY(p2, angle);\n      } else {\n        throw new Error(\"no way to calculate point.xy\");\n      }\n    }\n\n    if (!ignoreP1XYModification && p1[\"xy\"] == null) {\n      p1[\"xy\"] = this.getTargetXY(p1, Math.PI - angle);\n    }\n  } //p must be a shape\n\n\n  getTargetXY(p, angle) {\n    return p[\"shape\"][\"getExternalPoint\"] != null ? p[\"shape\"].getExternalPoint(angle, p[\"gap\"]) : Utils.getPointByAngle(p[\"shape\"].getCenterPoint(), angle, p[\"gap\"]);\n  }\n\n  process3PointsXY(p1, p2, p3) {\n    if (p3[\"xy\"] == null) {\n      if (p3[\"shape\"] != null) {\n        this.process2PointsXY(p2, p3, true);\n      } else if (p3[\"angle\"] != null) {\n        this.process2PointsXY(p1, p3, true);\n      } else {\n        throw new Error(\"no way to calculate point.xy\");\n      }\n    }\n\n    if (p2[\"xy\"] == null) {\n      if (p2[\"angle\"] != null) {\n        p2[\"xy\"] = Utils.getPointByAngle(p1[\"xy\"], p2[\"angle\"], p2[\"gap\"]);\n        this.process2PointsXY(p2, p1, true);\n      } else if (p2[\"shape\"] != null) {\n        //as p2 is a shape, p2[\"xy\"] can vary by angle between 2 other shape, so lets use an angle in the middle of that 2\n        this.process2PointsXY(p2, p1, true);\n        let c2 = p2[\"shape\"].getCenterPoint();\n        let angle1 = Utils.getAngle(c2[0], c2[1], p1[\"xy\"][0], p1[\"xy\"][1]);\n        let angle3 = Utils.getAngle(c2[0], c2[1], p3[\"xy\"][0], p3[\"xy\"][1]);\n        let angle2 = (angle1 + angle3) / 2; //if angle1 - angle3 > 180deg => correct mid angle\n\n        if (Math.abs(angle1 - angle3) > Math.PI) angle2 -= Math.PI;\n        p2[\"xy\"] = this.getTargetXY(p2, angle2);\n      } else {\n        throw new Error(\"no way to calculate point.xy\");\n      }\n    }\n  } // getNeighbourPoint(point) {\n  //     let index;\n  //     for (index = 0; index < this.path.length; index++) if (this.path[index] === point) break\n  //     return index === 0 ? this.path[1] : this.path[index - 1];\n  // }\n  //\n  // /**\n  //  * @param shape1 shape 1\n  //  * @param shape2 shape 2\n  //  * @param gap the gap between line and target shapes. gap>=0\n  //  */\n  // between(shape1, shape2, gap = 0) {\n  //     let c1 = shape1.getCenterPoint();\n  //     let c2 = shape2.getCenterPoint();\n  //     c1 = shape1.getExternalPoint(Utils.getAngle(c1[0], c1[1], c2[0], c2[1]), gap);\n  //     c2 = shape2.getExternalPoint(Utils.getAngle(c2[0], c2[1], c1[0], c1[1]), gap);\n  //     this.setPosition(c1);\n  //     this.lineTo(c2);\n  //     return this;\n  // }\n  //\n  // /**\n  //  * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or shape\n  //  */\n  // lineTo(point) {\n  //     if (typeof point[0] === 'string') {\n  //         let i = point[0].length - 1;\n  //         let c = point[0][i];\n  //         let v = Number(point[0].substring(0, i));\n  //         if (c === 'R' || c === 'r') {\n  //             this.secondP = this.getTargetPoint(v, point[1]);\n  //         } else if (c === 'D' || c === 'd') {\n  //             this.secondP = this.getTargetPoint(Utils.deg2Rad(v), point[1]);\n  //         } else {\n  //             throw new Error('wrong input');\n  //         }\n  //     } else {\n  //         this.secondP = point;\n  //     }\n  //     return this;\n  // }\n  //\n  // getTargetPoint(r, d) {\n  //     let p = this.getPosition();\n  //     return [p[0] + Math.cos(r) * d, p[1] + Math.sin(r) * d];\n  // }\n\n\n  getCenterPoint() {\n    let p = this.getPosition();\n    return [(p[0] + this.secondP[0]) / 2, (p[1] + this.secondP[1]) / 2];\n  }\n  /**\n   * show arrows on the line\n   * @param direction 0 or 1\n   * @param places array of float values, each is 0 - 1;\n   * @return Shape\n   */\n\n\n  showArrow(direction, places) {\n    this.direction = direction;\n    this.places = places;\n    return this;\n  }\n\n  drawArrow(canvasCtx, length, angle, x, y) {\n    canvasCtx.beginPath();\n    let p1 = [x + length * Math.cos(angle - Utils._PI6), y + length * Math.sin(angle - Utils._PI6)];\n    let p2 = [x + length * Math.cos(angle + Utils._PI6), y + length * Math.sin(angle + Utils._PI6)];\n    canvasCtx.moveTo(x, y);\n    canvasCtx.lineTo(p1[0], p1[1]);\n    canvasCtx.lineTo(p2[0], p2[1]);\n    canvasCtx.closePath();\n    super.render(canvasCtx);\n  } // render(canvasCtx) {\n  //     let p1 = this.getPosition();\n  //     canvasCtx.beginPath();\n  //     canvasCtx.moveTo(p1[0], p1[1]);\n  //     canvasCtx.lineTo(this.secondP[0], this.secondP[1]);\n  //     canvasCtx.closePath();\n  //     super.render(canvasCtx);\n  //     if (this.direction !== undefined && this.places !== undefined) {\n  //         if (!this.places[0])\n  //             this.places = [this.places];\n  //         let angle = this.direction ? Utils.getAngle(this.secondP[0], this.secondP[1], p1[0], p1[1]) : Utils.getAngle(p1[0], p1[1], this.secondP[0], this.secondP[1]);\n  //         for (let i = 0; i < this.places.length; i++) {\n  //             let x = p1[0] + (this.secondP[0] - p1[0]) * this.places[i];\n  //             let y = p1[1] + (this.secondP[1] - p1[1]) * this.places[i];\n  //             this.drawArrow(canvasCtx, 10, angle, x, y);\n  //         }\n  //     }\n  // }\n\n\n}\nexport class HLine extends Line {\n  setLength(l) {\n    l > 0 ? this.lineTo(['0D', l]) : this.lineTo(['180D', -l]);\n    return this;\n  }\n\n}\nexport class VLine extends Line {\n  setLength(l) {\n    l > 0 ? this.lineTo(['90D', l]) : this.lineTo(['270D', -l]);\n    return this;\n  }\n\n}\nexport class Vector extends Line {\n  constructor() {\n    super();\n    this.setStrokeColor('black').setFillColor('black').setStrokeWidth(2).showArrow(1, 1);\n  }\n\n}\nexport class HVector extends Vector {\n  setLabel(label) {\n    if (typeof label === 'string') label = new Text().setPosition(this.getCenterPoint()).setLabel(label).setOffset([0, -6]).setFontStyle('');\n    return super.setLabel(label);\n  }\n\n  setLength(l) {\n    return l > 0 ? this.lineTo(['0D', l]) : this.lineTo(['180D', -l]);\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/simple/line.js"],"names":["Shape","Utils","Text","Line","constructor","setStrokeWidth","setPosition","position","start","setStart","point","lineTo","end","setQuadraticPoint","qCurve","render","canvasCtx","preparePoints","beginPath","moveTo","quadraticCurveTo","addPoint","index","path","push","getPoint","i","length","ans","p","c","getTypeOf","v","Number","substring","normalizeRadian","deg2Rad","Error","process3PointsXY","process2PointsXY","p1","p2","ignoreP1XYModification","angle","c1","getCenterPoint","getPointByAngle","c2","getAngle","getTargetXY","Math","PI","getExternalPoint","p3","angle1","angle3","angle2","abs","getPosition","secondP","showArrow","direction","places","drawArrow","x","y","cos","_PI6","sin","closePath","HLine","setLength","l","VLine","Vector","setStrokeColor","setFillColor","HVector","setLabel","label","setOffset","setFontStyle"],"mappings":"AAAA,SAAQA,KAAR,QAAoB,SAApB;AACA,SAAQC,KAAR,QAAoB,sBAApB;AACA,SAAQC,IAAR,QAAmB,QAAnB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","sourcesContent":["import {Shape} from \"./shape\";\nimport {Utils} from \"../../../tools/utils\";\nimport {Text} from \"./text\";\n\n// export class Line extends Shape {\n//     path = [];\n//\n//     constructor() {\n//         super();\n//         this.setStrokeWidth(1);\n//     }\n//\n//     setPosition(position) {\n//         return this.addPoint(position, 0);\n//     }\n//\n//     addPoint(point, index = null) {\n//         if (index == null) {\n//             this.path.push(this.getPoint(point));\n//         } else {\n//             for (let i = this.path.length; i > index; i--)\n//                 this.path[i] = this.path[i - 1];\n//             this.path[index] = this.getPoint(point);\n//         }\n//         return this;\n//     }\n//\n//     /**\n//      * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n//      * you can have m & n before point location to make the line curvy:<br/>\n//      * ex.<br/>\n//      * [4, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [4, 5] in curvy shape<br/>\n//      * [90d, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [90d, 5] in curvy shape<br/>\n//      * [1r, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [1r, 5] in curvy shape<br/>\n//      * [shape, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [shape, 5] in curvy shape<br/>\n//      *\n//      */\n//     getPoint(point) {\n//         let ans = {};\n//         let p, c;\n//         if (point[2] != null && point[3] != null) {\n//             p = [point[2], point[3]];\n//             c = [point[0], point[1]];\n//         } else {\n//             p = [point[0], point[1]];\n//         }\n//         switch (this.getTypeOf(p)) {\n//             case \"number,number\"://[x,y]\n//                 ans[\"xy\"] = p;\n//                 break;\n//             case \"string,number\"://[intR,length] or [intD,length]\n//                 let i = p[0].length - 1;\n//                 let c = p[0][i];\n//                 let v = Number(p[0].substring(0, i));\n//                 if (c === 'R' || c === 'r') {\n//                     ans[\"angle\"] = Utils.normalizeRadian(v);\n//                     ans[\"gap\"] = p[1];\n//                 } else if (c === 'D' || c === 'd') {\n//                     ans[\"angle\"] = Utils.normalizeRadian(Utils.deg2Rad(v));\n//                     ans[\"gap\"] = p[1];\n//                 } else {\n//                     throw new Error('wrong input');\n//                 }\n//                 break;\n//             case \"object,number\"://[shape,gap]\n//                 ans[\"shape\"] = p[0];\n//                 ans[\"gap\"] = p[1];\n//                 break;\n//             default:\n//                 throw new Error('wrong input');\n//         }\n//         if (c != null) {\n//             ans[\"curve\"] = this.getPoint(c);\n//         }\n//         return ans;\n//     }\n//\n//     getTypeOf(point) {\n//         return typeof point[0] + ',' + typeof point[1]\n//     }\n//\n//     render(canvasCtx) {\n//         this.preparePoints();\n//         canvasCtx.beginPath();\n//         let p = this.path[0];\n//         canvasCtx.moveTo(p[\"xy\"][0], p[\"xy\"][1]);\n//         for (let i = 1; i < this.path.length; i++) {\n//             p = this.path[i];\n//             if (p[\"curve\"] != null)\n//                 canvasCtx.quadraticCurveTo(p[\"curve\"][\"xy\"][0], p[\"curve\"][\"xy\"][1], p[\"xy\"][0], p[\"xy\"][1]);\n//             else\n//                 canvasCtx.lineTo(p[\"xy\"][0], p[\"xy\"][1]);\n//         }\n//         // canvasCtx.closePath();\n//         super.render(canvasCtx);\n//     }\n//\n//     preparePoints() {\n//         debugger\n//         for (let i = 1; i < this.path.length; i++) {\n//             if (this.path[i][\"curve\"] != null)\n//                 this.process3PointsXY(this.path[i - 1], this.path[\"curve\"], this.path[i])\n//             else\n//                 this.process2PointsXY(this.path[i - 1], this.path[i])\n//         }\n//     }\n//\n//     process2PointsXY(p1, p2, ignoreP1XYModification = false) {\n//         let angle;\n//         if (p2[\"xy\"] == null) {\n//             let c1 = p1[\"xy\"] != null ? p1[\"xy\"] : p1[\"shape\"].getCenterPoint();\n//             if (p2[\"angle\"] != null) {\n//                 angle = p2[\"angle\"];\n//                 p2[\"xy\"] = Utils.getPointByAngle(c1, angle, p2[\"gap\"]);\n//             } else if (p2[\"shape\"] != null) {\n//                 let c2 = p2[\"shape\"].getCenterPoint();\n//                 angle = Utils.getAngle(c2[0], c2[1], c1[0], c1[1]);\n//                 p2[\"xy\"] = this.getTargetXY(p2, angle);\n//             } else {\n//                 throw new Error(\"no way to calculate point.xy\");\n//             }\n//         }\n//\n//         if (!ignoreP1XYModification && p1[\"xy\"] == null) {\n//             p1[\"xy\"] = this.getTargetXY(p1, Math.PI - angle)\n//         }\n//     }\n//\n//     //p must be a shape\n//     getTargetXY(p, angle) {\n//         return (p[\"shape\"][\"getExternalPoint\"] != null) ?\n//             p[\"shape\"].getExternalPoint(angle, p[\"gap\"]) :\n//             Utils.getPointByAngle(p[\"shape\"].getCenterPoint(), angle, p[\"gap\"])\n//     }\n//\n//     process3PointsXY(p1, p2, p3) {\n//         if (p3[\"xy\"] == null) {\n//             if (p3[\"shape\"] != null) {\n//                 this.process2PointsXY(p2, p3, true);\n//             } else if (p3[\"angle\"] != null) {\n//                 this.process2PointsXY(p1, p3, true);\n//             } else {\n//                 throw new Error(\"no way to calculate point.xy\");\n//             }\n//         }\n//\n//         if (p2[\"xy\"] == null) {\n//             if (p2[\"angle\"] != null) {\n//                 p2[\"xy\"] = Utils.getPointByAngle(p1[\"xy\"], p2[\"angle\"], p2[\"gap\"]);\n//                 this.process2PointsXY(p2, p1, true);\n//             } else if (p2[\"shape\"] != null) {\n//                 //as p2 is a shape, p2[\"xy\"] can vary by angle between 2 other shape, so lets use an angle in the middle of that 2\n//                 this.process2PointsXY(p2, p1, true);\n//                 let c2 = p2[\"shape\"].getCenterPoint();\n//                 let angle1 = Utils.getAngle(c2[0], c2[1], p1[\"xy\"][0], p1[\"xy\"][1]);\n//                 let angle3 = Utils.getAngle(c2[0], c2[1], p3[\"xy\"][0], p3[\"xy\"][1]);\n//                 let angle2 = (angle1 + angle3) / 2;\n//\n//                 //if angle1 - angle3 > 180deg => correct mid angle\n//                 if (Math.abs(angle1 - angle3) > Math.PI)\n//                     angle2 -= Math.PI;\n//                 p2[\"xy\"] = this.getTargetXY(p2, angle2);\n//             } else {\n//                 throw new Error(\"no way to calculate point.xy\");\n//             }\n//         }\n//     }\n//\n//     // getNeighbourPoint(point) {\n//     //     let index;\n//     //     for (index = 0; index < this.path.length; index++) if (this.path[index] === point) break\n//     //     return index === 0 ? this.path[1] : this.path[index - 1];\n//     // }\n//     //\n//     // /**\n//     //  * @param shape1 shape 1\n//     //  * @param shape2 shape 2\n//     //  * @param gap the gap between line and target shapes. gap>=0\n//     //  */\n//     // between(shape1, shape2, gap = 0) {\n//     //     let c1 = shape1.getCenterPoint();\n//     //     let c2 = shape2.getCenterPoint();\n//     //     c1 = shape1.getExternalPoint(Utils.getAngle(c1[0], c1[1], c2[0], c2[1]), gap);\n//     //     c2 = shape2.getExternalPoint(Utils.getAngle(c2[0], c2[1], c1[0], c1[1]), gap);\n//     //     this.setPosition(c1);\n//     //     this.lineTo(c2);\n//     //     return this;\n//     // }\n//     //\n//     // /**\n//     //  * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or shape\n//     //  */\n//     // lineTo(point) {\n//     //     if (typeof point[0] === 'string') {\n//     //         let i = point[0].length - 1;\n//     //         let c = point[0][i];\n//     //         let v = Number(point[0].substring(0, i));\n//     //         if (c === 'R' || c === 'r') {\n//     //             this.secondP = this.getTargetPoint(v, point[1]);\n//     //         } else if (c === 'D' || c === 'd') {\n//     //             this.secondP = this.getTargetPoint(Utils.deg2Rad(v), point[1]);\n//     //         } else {\n//     //             throw new Error('wrong input');\n//     //         }\n//     //     } else {\n//     //         this.secondP = point;\n//     //     }\n//     //     return this;\n//     // }\n//     //\n//     // getTargetPoint(r, d) {\n//     //     let p = this.getPosition();\n//     //     return [p[0] + Math.cos(r) * d, p[1] + Math.sin(r) * d];\n//     // }\n//\n//     getCenterPoint() {\n//         let p = this.getPosition();\n//         return [(p[0] + this.secondP[0]) / 2, (p[1] + this.secondP[1]) / 2]\n//     }\n//\n//     /**\n//      * show arrows on the line\n//      * @param direction 0 or 1\n//      * @param places array of float values, each is 0 - 1;\n//      * @return Shape\n//      */\n//     showArrow(direction, places) {\n//         this.direction = direction;\n//         this.places = places;\n//         return this;\n//     }\n//\n//     drawArrow(canvasCtx, length, angle, x, y) {\n//         canvasCtx.beginPath();\n//         let p1 = [x + length * Math.cos(angle - Utils._PI6), y + length * Math.sin(angle - Utils._PI6)];\n//         let p2 = [x + length * Math.cos(angle + Utils._PI6), y + length * Math.sin(angle + Utils._PI6)];\n//         canvasCtx.moveTo(x, y);\n//         canvasCtx.lineTo(p1[0], p1[1]);\n//         canvasCtx.lineTo(p2[0], p2[1]);\n//         canvasCtx.closePath();\n//         super.render(canvasCtx);\n//     }\n//\n//     // render(canvasCtx) {\n//     //     let p1 = this.getPosition();\n//     //     canvasCtx.beginPath();\n//     //     canvasCtx.moveTo(p1[0], p1[1]);\n//     //     canvasCtx.lineTo(this.secondP[0], this.secondP[1]);\n//     //     canvasCtx.closePath();\n//     //     super.render(canvasCtx);\n//     //     if (this.direction !== undefined && this.places !== undefined) {\n//     //         if (!this.places[0])\n//     //             this.places = [this.places];\n//     //         let angle = this.direction ? Utils.getAngle(this.secondP[0], this.secondP[1], p1[0], p1[1]) : Utils.getAngle(p1[0], p1[1], this.secondP[0], this.secondP[1]);\n//     //         for (let i = 0; i < this.places.length; i++) {\n//     //             let x = p1[0] + (this.secondP[0] - p1[0]) * this.places[i];\n//     //             let y = p1[1] + (this.secondP[1] - p1[1]) * this.places[i];\n//     //             this.drawArrow(canvasCtx, 10, angle, x, y);\n//     //         }\n//     //     }\n//     // }\n// }\n\nexport class Line extends Shape {\n    start;\n    end;\n    qCurve;\n\n    constructor() {\n        super();\n        this.setStrokeWidth(1);\n    }\n\n    setPosition(position) {\n        this.start = position;\n        return this;\n    }\n\n    setStart(point) {\n        return this.setPosition(point);\n    }\n\n    lineTo(point) {\n        this.end = point;\n        return this;\n    }\n\n    setQuadraticPoint(point) {\n        this.qCurve = point;\n        return this;\n    }\n\n    render(canvasCtx) {\n        this.preparePoints();\n        canvasCtx.beginPath();\n        canvasCtx.moveTo(this.start);\n        if (this.qCurve)\n            canvasCtx.quadraticCurveTo(this.qCurve[0], this.qCurve[1], this.end[0], this.end[1]);\n        else\n            canvasCtx.lineTo(this.end[0], this.end[1]);\n\n        // canvasCtx.closePath();\n        super.render(canvasCtx);\n    }\n\n    addPoint(point, index = null) {\n        if (index == null) {\n            this.path.push(this.getPoint(point));\n        } else {\n            for (let i = this.path.length; i > index; i--)\n                this.path[i] = this.path[i - 1];\n            this.path[index] = this.getPoint(point);\n        }\n        return this;\n    }\n\n    /**\n     * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n     * you can have m & n before point location to make the line curvy:<br/>\n     * ex.<br/>\n     * [4, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [4, 5] in curvy shape<br/>\n     * [90d, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [90d, 5] in curvy shape<br/>\n     * [1r, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [1r, 5] in curvy shape<br/>\n     * [shape, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [shape, 5] in curvy shape<br/>\n     *\n     */\n    getPoint(point) {\n        let ans = {};\n        let p, c;\n        if (point[2] != null && point[3] != null) {\n            p = [point[2], point[3]];\n            c = [point[0], point[1]];\n        } else {\n            p = [point[0], point[1]];\n        }\n        switch (this.getTypeOf(p)) {\n            case \"number,number\"://[x,y]\n                ans[\"xy\"] = p;\n                break;\n            case \"string,number\"://[intR,length] or [intD,length]\n                let i = p[0].length - 1;\n                let c = p[0][i];\n                let v = Number(p[0].substring(0, i));\n                if (c === 'R' || c === 'r') {\n                    ans[\"angle\"] = Utils.normalizeRadian(v);\n                    ans[\"gap\"] = p[1];\n                } else if (c === 'D' || c === 'd') {\n                    ans[\"angle\"] = Utils.normalizeRadian(Utils.deg2Rad(v));\n                    ans[\"gap\"] = p[1];\n                } else {\n                    throw new Error('wrong input');\n                }\n                break;\n            case \"object,number\"://[shape,gap]\n                ans[\"shape\"] = p[0];\n                ans[\"gap\"] = p[1];\n                break;\n            default:\n                throw new Error('wrong input');\n        }\n        if (c != null) {\n            ans[\"curve\"] = this.getPoint(c);\n        }\n        return ans;\n    }\n\n    getTypeOf(point) {\n        return typeof point[0] + ',' + typeof point[1]\n    }\n\n    preparePoints() {\n        debugger\n        for (let i = 1; i < this.path.length; i++) {\n            if (this.path[i][\"curve\"] != null)\n                this.process3PointsXY(this.path[i - 1], this.path[\"curve\"], this.path[i])\n            else\n                this.process2PointsXY(this.path[i - 1], this.path[i])\n        }\n    }\n\n    process2PointsXY(p1, p2, ignoreP1XYModification = false) {\n        let angle;\n        if (p2[\"xy\"] == null) {\n            let c1 = p1[\"xy\"] != null ? p1[\"xy\"] : p1[\"shape\"].getCenterPoint();\n            if (p2[\"angle\"] != null) {\n                angle = p2[\"angle\"];\n                p2[\"xy\"] = Utils.getPointByAngle(c1, angle, p2[\"gap\"]);\n            } else if (p2[\"shape\"] != null) {\n                let c2 = p2[\"shape\"].getCenterPoint();\n                angle = Utils.getAngle(c2[0], c2[1], c1[0], c1[1]);\n                p2[\"xy\"] = this.getTargetXY(p2, angle);\n            } else {\n                throw new Error(\"no way to calculate point.xy\");\n            }\n        }\n\n        if (!ignoreP1XYModification && p1[\"xy\"] == null) {\n            p1[\"xy\"] = this.getTargetXY(p1, Math.PI - angle)\n        }\n    }\n\n    //p must be a shape\n    getTargetXY(p, angle) {\n        return (p[\"shape\"][\"getExternalPoint\"] != null) ?\n            p[\"shape\"].getExternalPoint(angle, p[\"gap\"]) :\n            Utils.getPointByAngle(p[\"shape\"].getCenterPoint(), angle, p[\"gap\"])\n    }\n\n    process3PointsXY(p1, p2, p3) {\n        if (p3[\"xy\"] == null) {\n            if (p3[\"shape\"] != null) {\n                this.process2PointsXY(p2, p3, true);\n            } else if (p3[\"angle\"] != null) {\n                this.process2PointsXY(p1, p3, true);\n            } else {\n                throw new Error(\"no way to calculate point.xy\");\n            }\n        }\n\n        if (p2[\"xy\"] == null) {\n            if (p2[\"angle\"] != null) {\n                p2[\"xy\"] = Utils.getPointByAngle(p1[\"xy\"], p2[\"angle\"], p2[\"gap\"]);\n                this.process2PointsXY(p2, p1, true);\n            } else if (p2[\"shape\"] != null) {\n                //as p2 is a shape, p2[\"xy\"] can vary by angle between 2 other shape, so lets use an angle in the middle of that 2\n                this.process2PointsXY(p2, p1, true);\n                let c2 = p2[\"shape\"].getCenterPoint();\n                let angle1 = Utils.getAngle(c2[0], c2[1], p1[\"xy\"][0], p1[\"xy\"][1]);\n                let angle3 = Utils.getAngle(c2[0], c2[1], p3[\"xy\"][0], p3[\"xy\"][1]);\n                let angle2 = (angle1 + angle3) / 2;\n\n                //if angle1 - angle3 > 180deg => correct mid angle\n                if (Math.abs(angle1 - angle3) > Math.PI)\n                    angle2 -= Math.PI;\n                p2[\"xy\"] = this.getTargetXY(p2, angle2);\n            } else {\n                throw new Error(\"no way to calculate point.xy\");\n            }\n        }\n    }\n\n    // getNeighbourPoint(point) {\n    //     let index;\n    //     for (index = 0; index < this.path.length; index++) if (this.path[index] === point) break\n    //     return index === 0 ? this.path[1] : this.path[index - 1];\n    // }\n    //\n    // /**\n    //  * @param shape1 shape 1\n    //  * @param shape2 shape 2\n    //  * @param gap the gap between line and target shapes. gap>=0\n    //  */\n    // between(shape1, shape2, gap = 0) {\n    //     let c1 = shape1.getCenterPoint();\n    //     let c2 = shape2.getCenterPoint();\n    //     c1 = shape1.getExternalPoint(Utils.getAngle(c1[0], c1[1], c2[0], c2[1]), gap);\n    //     c2 = shape2.getExternalPoint(Utils.getAngle(c2[0], c2[1], c1[0], c1[1]), gap);\n    //     this.setPosition(c1);\n    //     this.lineTo(c2);\n    //     return this;\n    // }\n    //\n    // /**\n    //  * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or shape\n    //  */\n    // lineTo(point) {\n    //     if (typeof point[0] === 'string') {\n    //         let i = point[0].length - 1;\n    //         let c = point[0][i];\n    //         let v = Number(point[0].substring(0, i));\n    //         if (c === 'R' || c === 'r') {\n    //             this.secondP = this.getTargetPoint(v, point[1]);\n    //         } else if (c === 'D' || c === 'd') {\n    //             this.secondP = this.getTargetPoint(Utils.deg2Rad(v), point[1]);\n    //         } else {\n    //             throw new Error('wrong input');\n    //         }\n    //     } else {\n    //         this.secondP = point;\n    //     }\n    //     return this;\n    // }\n    //\n    // getTargetPoint(r, d) {\n    //     let p = this.getPosition();\n    //     return [p[0] + Math.cos(r) * d, p[1] + Math.sin(r) * d];\n    // }\n\n    getCenterPoint() {\n        let p = this.getPosition();\n        return [(p[0] + this.secondP[0]) / 2, (p[1] + this.secondP[1]) / 2]\n    }\n\n    /**\n     * show arrows on the line\n     * @param direction 0 or 1\n     * @param places array of float values, each is 0 - 1;\n     * @return Shape\n     */\n    showArrow(direction, places) {\n        this.direction = direction;\n        this.places = places;\n        return this;\n    }\n\n    drawArrow(canvasCtx, length, angle, x, y) {\n        canvasCtx.beginPath();\n        let p1 = [x + length * Math.cos(angle - Utils._PI6), y + length * Math.sin(angle - Utils._PI6)];\n        let p2 = [x + length * Math.cos(angle + Utils._PI6), y + length * Math.sin(angle + Utils._PI6)];\n        canvasCtx.moveTo(x, y);\n        canvasCtx.lineTo(p1[0], p1[1]);\n        canvasCtx.lineTo(p2[0], p2[1]);\n        canvasCtx.closePath();\n        super.render(canvasCtx);\n    }\n\n    // render(canvasCtx) {\n    //     let p1 = this.getPosition();\n    //     canvasCtx.beginPath();\n    //     canvasCtx.moveTo(p1[0], p1[1]);\n    //     canvasCtx.lineTo(this.secondP[0], this.secondP[1]);\n    //     canvasCtx.closePath();\n    //     super.render(canvasCtx);\n    //     if (this.direction !== undefined && this.places !== undefined) {\n    //         if (!this.places[0])\n    //             this.places = [this.places];\n    //         let angle = this.direction ? Utils.getAngle(this.secondP[0], this.secondP[1], p1[0], p1[1]) : Utils.getAngle(p1[0], p1[1], this.secondP[0], this.secondP[1]);\n    //         for (let i = 0; i < this.places.length; i++) {\n    //             let x = p1[0] + (this.secondP[0] - p1[0]) * this.places[i];\n    //             let y = p1[1] + (this.secondP[1] - p1[1]) * this.places[i];\n    //             this.drawArrow(canvasCtx, 10, angle, x, y);\n    //         }\n    //     }\n    // }\n}\n\nexport class HLine\n    extends Line {\n    setLength(l) {\n        l > 0 ?\n            this.lineTo(['0D', l]) :\n            this.lineTo(['180D', -l])\n        return this;\n    }\n}\n\nexport class VLine extends Line {\n    setLength(l) {\n        l > 0 ?\n            this.lineTo(['90D', l]) :\n            this.lineTo(['270D', -l])\n        return this;\n    }\n}\n\nexport class Vector extends Line {\n    constructor() {\n        super();\n        this.setStrokeColor('black')\n            .setFillColor('black')\n            .setStrokeWidth(2)\n            .showArrow(1, 1);\n    }\n}\n\nexport class HVector extends Vector {\n    setLabel(label) {\n        if (typeof label === 'string')\n            label = new Text()\n                .setPosition(this.getCenterPoint())\n                .setLabel(label)\n                .setOffset([0, -6])\n                .setFontStyle('');\n        return super.setLabel(label);\n    }\n\n    setLength(l) {\n        return (l > 0) ?\n            this.lineTo(['0D', l]) :\n            this.lineTo(['180D', -l])\n    }\n}"]},"metadata":{},"sourceType":"module"}