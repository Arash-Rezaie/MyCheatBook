{"ast":null,"code":"import { Shape } from \"./shape\";\nimport { Utils } from \"../../../tools/utils\";\nimport { Text } from \"./text\";\nexport class Line extends Shape {\n  constructor() {\n    super();\n    this.path = [];\n    this.setStrokeWidth(1);\n  }\n\n  setPosition(position) {\n    return this.addPoint(position, 0);\n  }\n\n  addPoint(point, index = null) {\n    debugger;\n\n    if (!index) {\n      this.path.push(this.getPoint(point));\n    } else {\n      for (let i = this.path.length; i > index; i--) this.path[i] = this.path[i - 1];\n\n      this.path[index] = this.getPoint(point);\n    }\n\n    return this;\n  }\n  /**\n   * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n   * you can have m & n before point location to make the line curvy:<br/>\n   * ex.<br/>\n   * [4, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [4, 5] in curvy shape<br/>\n   * [90d, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [90d, 5] in curvy shape<br/>\n   * [1r, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [1r, 5] in curvy shape<br/>\n   * [shape, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [shape, 5] in curvy shape<br/>\n   *\n   */\n\n\n  getPoint(point) {\n    let ans = {};\n    let p, c;\n\n    if (point[2] && point[3]) {\n      p = [point[2], point[3]];\n      c = [point[0], point[1]];\n    } else {\n      p = [point[0], point[1]];\n    }\n\n    switch (this.getTypeOf(p)) {\n      case \"number,number\":\n        //[x,y]\n        ans[\"xy\"] = p;\n        break;\n\n      case \"string,number\":\n        //[intR,length] or [intD,length]\n        let i = p[0].length - 1;\n        let c = p[0][i];\n        let v = Number(p[0].substring(0, i));\n\n        if (c === 'R' || c === 'r') {\n          ans[\"angle\"] = v;\n          ans[\"gap\"] = p[1];\n        } else if (c === 'D' || c === 'd') {\n          ans[\"angle\"] = Utils.normalizeRadian(Utils.deg2Rad(v));\n          ans[\"gap\"] = p[1];\n        } else {\n          throw new Error('wrong input');\n        }\n\n        break;\n\n      case \"object,number\":\n        //[shape,gap]\n        ans[\"shape\"] = Utils.normalizeRadian(p[0]);\n        ans[\"gap\"] = p[1];\n        break;\n\n      default:\n        throw new Error('wrong input');\n    }\n\n    if (c) {\n      ans[\"curve\"] = this.getPoint(c);\n    }\n\n    return ans;\n  }\n\n  getTypeOf(point) {\n    return typeof point[0] + ',' + typeof point[1];\n  }\n\n  preparePoints() {\n    let p;\n\n    for (let i = 0; i < this.path.length - 1; i++) {\n      p = this.path[i];\n\n      if (!p[\"xy\"] || p[\"curve\"] && !p[\"curve\"][\"xy\"]) {\n        this.preprocessPoints(p, p[\"curve\"]);\n      } else if (!p[\"xy\"] || !this.path[i + 1][\"xy\"]) {\n        this.preprocessPoints(p, this.path[i + 1]);\n      }\n    }\n  }\n\n  preprocessPoints(point1, point2) {\n    if (!point2[\"angle\"]) {\n      let p1 = point1[\"xy\"] ? point1[\"xy\"] : point1[\"shape\"].getCenterPoint();\n      let p2 = point2[\"xy\"] ? point2[\"xy\"] : point2[\"shape\"].getCenterPoint();\n      point2[\"angle\"] = Utils.getAngle(p2[0], p2[1], p1[0], p1[1]);\n    }\n\n    if (!point1[\"xy\"]) {\n      point1[\"xy\"] = this.getTargetPointOfShape(point1, Math.PI - point2[\"angle\"], point1[\"gap\"]);\n    }\n\n    if (!point2[\"xy\"]) {\n      try {\n        point2[\"xy\"] = this.getTargetPointOfShape(point2, point2[\"angle\"], point2[\"gap\"]);\n      } catch (e) {\n        point2[\"xy\"] = [point1[\"xy\"][0] + point2[\"gap\"] * Math.cos(point2[\"angle\"]), point1[\"xy\"][1] + point2[\"gap\"] * Math.sin(point2[\"angle\"])];\n      }\n    }\n  }\n\n  getTargetPointOfShape(point, angle, gap = 0) {\n    if (point[\"shape\"]) {\n      if (point[\"shape\"][\"getExternalPoint\"]) {\n        return point[\"shape\"].getExternalPoint(angle, gap);\n      } else {\n        let m = point[\"shape\"].getCenterPoint();\n        return [m[0] + gap * Math.cos(angle), m[1] + gap * Math.sin(angle)];\n      }\n    }\n\n    throw new Error('the point is not a shape');\n  }\n\n  render(canvasCtx) {\n    debugger;\n    this.preparePoints();\n    canvasCtx.beginPath();\n    canvasCtx.moveTo(this.path[0][\"xy\"][0], this.path[0][\"xy\"][1]);\n\n    for (let i = 1; i < this.path.length; i++) {\n      if (this.path[i][\"curve\"]) canvasCtx.quadraticCurveTo(this.path[i][\"xy\"][0], this.path[i][\"xy\"][1]);else canvasCtx.lineTo(this.path[i][\"xy\"][0], this.path[i][\"xy\"][1]);\n    } // canvasCtx.closePath();\n\n\n    super.render(canvasCtx);\n  } // getNeighbourPoint(point) {\n  //     let index;\n  //     for (index = 0; index < this.path.length; index++) if (this.path[index] === point) break\n  //     return index === 0 ? this.path[1] : this.path[index - 1];\n  // }\n  //\n  // /**\n  //  * @param shape1 shape 1\n  //  * @param shape2 shape 2\n  //  * @param gap the gap between line and target shapes. gap>=0\n  //  */\n  // between(shape1, shape2, gap = 0) {\n  //     let c1 = shape1.getCenterPoint();\n  //     let c2 = shape2.getCenterPoint();\n  //     c1 = shape1.getExternalPoint(Utils.getAngle(c1[0], c1[1], c2[0], c2[1]), gap);\n  //     c2 = shape2.getExternalPoint(Utils.getAngle(c2[0], c2[1], c1[0], c1[1]), gap);\n  //     this.setPosition(c1);\n  //     this.lineTo(c2);\n  //     return this;\n  // }\n  //\n  // /**\n  //  * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or shape\n  //  */\n  // lineTo(point) {\n  //     if (typeof point[0] === 'string') {\n  //         let i = point[0].length - 1;\n  //         let c = point[0][i];\n  //         let v = Number(point[0].substring(0, i));\n  //         if (c === 'R' || c === 'r') {\n  //             this.secondP = this.getTargetPoint(v, point[1]);\n  //         } else if (c === 'D' || c === 'd') {\n  //             this.secondP = this.getTargetPoint(Utils.deg2Rad(v), point[1]);\n  //         } else {\n  //             throw new Error('wrong input');\n  //         }\n  //     } else {\n  //         this.secondP = point;\n  //     }\n  //     return this;\n  // }\n  //\n  // getTargetPoint(r, d) {\n  //     let p = this.getPosition();\n  //     return [p[0] + Math.cos(r) * d, p[1] + Math.sin(r) * d];\n  // }\n\n\n  getCenterPoint() {\n    let p = this.getPosition();\n    return [(p[0] + this.secondP[0]) / 2, (p[1] + this.secondP[1]) / 2];\n  }\n  /**\n   * show arrows on the line\n   * @param direction 0 or 1\n   * @param places array of float values, each is 0 - 1;\n   * @return Shape\n   */\n\n\n  showArrow(direction, places) {\n    this.direction = direction;\n    this.places = places;\n    return this;\n  }\n\n  drawArrow(canvasCtx, length, angle, x, y) {\n    canvasCtx.beginPath();\n    let p1 = [x + length * Math.cos(angle - Utils._PI6), y + length * Math.sin(angle - Utils._PI6)];\n    let p2 = [x + length * Math.cos(angle + Utils._PI6), y + length * Math.sin(angle + Utils._PI6)];\n    canvasCtx.moveTo(x, y);\n    canvasCtx.lineTo(p1[0], p1[1]);\n    canvasCtx.lineTo(p2[0], p2[1]);\n    canvasCtx.closePath();\n    super.render(canvasCtx);\n  } // render(canvasCtx) {\n  //     let p1 = this.getPosition();\n  //     canvasCtx.beginPath();\n  //     canvasCtx.moveTo(p1[0], p1[1]);\n  //     canvasCtx.lineTo(this.secondP[0], this.secondP[1]);\n  //     canvasCtx.closePath();\n  //     super.render(canvasCtx);\n  //     if (this.direction !== undefined && this.places !== undefined) {\n  //         if (!this.places[0])\n  //             this.places = [this.places];\n  //         let angle = this.direction ? Utils.getAngle(this.secondP[0], this.secondP[1], p1[0], p1[1]) : Utils.getAngle(p1[0], p1[1], this.secondP[0], this.secondP[1]);\n  //         for (let i = 0; i < this.places.length; i++) {\n  //             let x = p1[0] + (this.secondP[0] - p1[0]) * this.places[i];\n  //             let y = p1[1] + (this.secondP[1] - p1[1]) * this.places[i];\n  //             this.drawArrow(canvasCtx, 10, angle, x, y);\n  //         }\n  //     }\n  // }\n\n\n}\nexport class HLine extends Line {\n  setLength(l) {\n    l > 0 ? this.lineTo(['0D', l]) : this.lineTo(['180D', -l]);\n    return this;\n  }\n\n}\nexport class VLine extends Line {\n  setLength(l) {\n    l > 0 ? this.lineTo(['90D', l]) : this.lineTo(['270D', -l]);\n    return this;\n  }\n\n}\nexport class Vector extends Line {\n  constructor() {\n    super();\n    this.setStrokeColor('black').setFillColor('black').setStrokeWidth(2).showArrow(1, 1);\n  }\n\n}\nexport class HVector extends Vector {\n  setLabel(label) {\n    if (typeof label === 'string') label = new Text().setPosition(this.getCenterPoint()).setLabel(label).setOffset([0, -6]).setFontStyle('');\n    return super.setLabel(label);\n  }\n\n  setLength(l) {\n    return l > 0 ? this.lineTo(['0D', l]) : this.lineTo(['180D', -l]);\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/simple/line.js"],"names":["Shape","Utils","Text","Line","constructor","path","setStrokeWidth","setPosition","position","addPoint","point","index","push","getPoint","i","length","ans","p","c","getTypeOf","v","Number","substring","normalizeRadian","deg2Rad","Error","preparePoints","preprocessPoints","point1","point2","p1","getCenterPoint","p2","getAngle","getTargetPointOfShape","Math","PI","e","cos","sin","angle","gap","getExternalPoint","m","render","canvasCtx","beginPath","moveTo","quadraticCurveTo","lineTo","getPosition","secondP","showArrow","direction","places","drawArrow","x","y","_PI6","closePath","HLine","setLength","l","VLine","Vector","setStrokeColor","setFillColor","HVector","setLabel","label","setOffset","setFontStyle"],"mappings":"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","sourcesContent":["import {Shape} from \"./shape\";\nimport {Utils} from \"../../../tools/utils\";\nimport {Text} from \"./text\";\n\nexport class Line extends Shape {\n    path = [];\n\n    constructor() {\n        super();\n        this.setStrokeWidth(1);\n    }\n\n    setPosition(position) {\n        return this.addPoint(position, 0);\n    }\n\n    addPoint(point, index = null) {\n        debugger\n        if (!index) {\n            this.path.push(this.getPoint(point));\n        } else {\n            for (let i = this.path.length; i > index; i--)\n                this.path[i] = this.path[i - 1];\n            this.path[index] = this.getPoint(point);\n        }\n        return this;\n    }\n\n    /**\n     * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n     * you can have m & n before point location to make the line curvy:<br/>\n     * ex.<br/>\n     * [4, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [4, 5] in curvy shape<br/>\n     * [90d, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [90d, 5] in curvy shape<br/>\n     * [1r, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [1r, 5] in curvy shape<br/>\n     * [shape, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [shape, 5] in curvy shape<br/>\n     *\n     */\n    getPoint(point) {\n        let ans = {};\n        let p, c;\n        if (point[2] && point[3]) {\n            p = [point[2], point[3]];\n            c = [point[0], point[1]];\n        } else {\n            p = [point[0], point[1]];\n        }\n        switch (this.getTypeOf(p)) {\n            case \"number,number\"://[x,y]\n                ans[\"xy\"] = p;\n                break;\n            case \"string,number\"://[intR,length] or [intD,length]\n                let i = p[0].length - 1;\n                let c = p[0][i];\n                let v = Number(p[0].substring(0, i));\n                if (c === 'R' || c === 'r') {\n                    ans[\"angle\"] = v;\n                    ans[\"gap\"] = p[1];\n                } else if (c === 'D' || c === 'd') {\n                    ans[\"angle\"] = Utils.normalizeRadian(Utils.deg2Rad(v));\n                    ans[\"gap\"] = p[1];\n                } else {\n                    throw new Error('wrong input');\n                }\n                break;\n            case \"object,number\"://[shape,gap]\n                ans[\"shape\"] = Utils.normalizeRadian(p[0]);\n                ans[\"gap\"] = p[1];\n                break;\n            default:\n                throw new Error('wrong input');\n        }\n        if (c) {\n            ans[\"curve\"] = this.getPoint(c);\n        }\n        return ans;\n    }\n\n    getTypeOf(point) {\n        return typeof point[0] + ',' + typeof point[1]\n    }\n\n    preparePoints() {\n        let p;\n        for (let i = 0; i < this.path.length - 1; i++) {\n            p = this.path[i];\n            if (!p[\"xy\"] || (p[\"curve\"] && !p[\"curve\"][\"xy\"])) {\n                this.preprocessPoints(p, p[\"curve\"]);\n            } else if (!p[\"xy\"] || !this.path[i + 1][\"xy\"]) {\n                this.preprocessPoints(p, this.path[i + 1]);\n            }\n        }\n    }\n\n    preprocessPoints(point1, point2) {\n        if (!point2[\"angle\"]) {\n            let p1 = point1[\"xy\"] ? point1[\"xy\"] : point1[\"shape\"].getCenterPoint();\n            let p2 = point2[\"xy\"] ? point2[\"xy\"] : point2[\"shape\"].getCenterPoint();\n            point2[\"angle\"] = Utils.getAngle(p2[0], p2[1], p1[0], p1[1]);\n        }\n\n        if (!point1[\"xy\"]) {\n            point1[\"xy\"] = this.getTargetPointOfShape(point1, Math.PI - point2[\"angle\"], point1[\"gap\"])\n        }\n\n        if (!point2[\"xy\"]) {\n            try {\n                point2[\"xy\"] = this.getTargetPointOfShape(point2, point2[\"angle\"], point2[\"gap\"])\n            } catch (e) {\n                point2[\"xy\"] = [point1[\"xy\"][0] + point2[\"gap\"] * Math.cos(point2[\"angle\"]), point1[\"xy\"][1] + point2[\"gap\"] * Math.sin(point2[\"angle\"])];\n            }\n        }\n    }\n\n    getTargetPointOfShape(point, angle, gap = 0) {\n        if (point[\"shape\"]) {\n            if (point[\"shape\"][\"getExternalPoint\"]) {\n                return point[\"shape\"].getExternalPoint(angle, gap);\n            } else {\n                let m = point[\"shape\"].getCenterPoint();\n                return [m[0] + gap * Math.cos(angle), m[1] + gap * Math.sin(angle)];\n            }\n        }\n        throw new Error('the point is not a shape');\n    }\n\n    render(canvasCtx) {\n        debugger\n        this.preparePoints();\n        canvasCtx.beginPath();\n        canvasCtx.moveTo(this.path[0][\"xy\"][0], this.path[0][\"xy\"][1]);\n        for (let i = 1; i < this.path.length; i++) {\n            if (this.path[i][\"curve\"])\n                canvasCtx.quadraticCurveTo(this.path[i][\"xy\"][0], this.path[i][\"xy\"][1]);\n            else\n                canvasCtx.lineTo(this.path[i][\"xy\"][0], this.path[i][\"xy\"][1]);\n        }\n        // canvasCtx.closePath();\n        super.render(canvasCtx);\n    }\n\n    // getNeighbourPoint(point) {\n    //     let index;\n    //     for (index = 0; index < this.path.length; index++) if (this.path[index] === point) break\n    //     return index === 0 ? this.path[1] : this.path[index - 1];\n    // }\n    //\n    // /**\n    //  * @param shape1 shape 1\n    //  * @param shape2 shape 2\n    //  * @param gap the gap between line and target shapes. gap>=0\n    //  */\n    // between(shape1, shape2, gap = 0) {\n    //     let c1 = shape1.getCenterPoint();\n    //     let c2 = shape2.getCenterPoint();\n    //     c1 = shape1.getExternalPoint(Utils.getAngle(c1[0], c1[1], c2[0], c2[1]), gap);\n    //     c2 = shape2.getExternalPoint(Utils.getAngle(c2[0], c2[1], c1[0], c1[1]), gap);\n    //     this.setPosition(c1);\n    //     this.lineTo(c2);\n    //     return this;\n    // }\n    //\n    // /**\n    //  * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or shape\n    //  */\n    // lineTo(point) {\n    //     if (typeof point[0] === 'string') {\n    //         let i = point[0].length - 1;\n    //         let c = point[0][i];\n    //         let v = Number(point[0].substring(0, i));\n    //         if (c === 'R' || c === 'r') {\n    //             this.secondP = this.getTargetPoint(v, point[1]);\n    //         } else if (c === 'D' || c === 'd') {\n    //             this.secondP = this.getTargetPoint(Utils.deg2Rad(v), point[1]);\n    //         } else {\n    //             throw new Error('wrong input');\n    //         }\n    //     } else {\n    //         this.secondP = point;\n    //     }\n    //     return this;\n    // }\n    //\n    // getTargetPoint(r, d) {\n    //     let p = this.getPosition();\n    //     return [p[0] + Math.cos(r) * d, p[1] + Math.sin(r) * d];\n    // }\n\n    getCenterPoint() {\n        let p = this.getPosition();\n        return [(p[0] + this.secondP[0]) / 2, (p[1] + this.secondP[1]) / 2]\n    }\n\n    /**\n     * show arrows on the line\n     * @param direction 0 or 1\n     * @param places array of float values, each is 0 - 1;\n     * @return Shape\n     */\n    showArrow(direction, places) {\n        this.direction = direction;\n        this.places = places;\n        return this;\n    }\n\n    drawArrow(canvasCtx, length, angle, x, y) {\n        canvasCtx.beginPath();\n        let p1 = [x + length * Math.cos(angle - Utils._PI6), y + length * Math.sin(angle - Utils._PI6)];\n        let p2 = [x + length * Math.cos(angle + Utils._PI6), y + length * Math.sin(angle + Utils._PI6)];\n        canvasCtx.moveTo(x, y);\n        canvasCtx.lineTo(p1[0], p1[1]);\n        canvasCtx.lineTo(p2[0], p2[1]);\n        canvasCtx.closePath();\n        super.render(canvasCtx);\n    }\n\n    // render(canvasCtx) {\n    //     let p1 = this.getPosition();\n    //     canvasCtx.beginPath();\n    //     canvasCtx.moveTo(p1[0], p1[1]);\n    //     canvasCtx.lineTo(this.secondP[0], this.secondP[1]);\n    //     canvasCtx.closePath();\n    //     super.render(canvasCtx);\n    //     if (this.direction !== undefined && this.places !== undefined) {\n    //         if (!this.places[0])\n    //             this.places = [this.places];\n    //         let angle = this.direction ? Utils.getAngle(this.secondP[0], this.secondP[1], p1[0], p1[1]) : Utils.getAngle(p1[0], p1[1], this.secondP[0], this.secondP[1]);\n    //         for (let i = 0; i < this.places.length; i++) {\n    //             let x = p1[0] + (this.secondP[0] - p1[0]) * this.places[i];\n    //             let y = p1[1] + (this.secondP[1] - p1[1]) * this.places[i];\n    //             this.drawArrow(canvasCtx, 10, angle, x, y);\n    //         }\n    //     }\n    // }\n}\n\nexport class HLine\n    extends Line {\n    setLength(l) {\n        l > 0 ?\n            this.lineTo(['0D', l]) :\n            this.lineTo(['180D', -l])\n        return this;\n    }\n}\n\nexport class VLine extends Line {\n    setLength(l) {\n        l > 0 ?\n            this.lineTo(['90D', l]) :\n            this.lineTo(['270D', -l])\n        return this;\n    }\n}\n\nexport class Vector extends Line {\n    constructor() {\n        super();\n        this.setStrokeColor('black')\n            .setFillColor('black')\n            .setStrokeWidth(2)\n            .showArrow(1, 1);\n    }\n}\n\nexport class HVector extends Vector {\n    setLabel(label) {\n        if (typeof label === 'string')\n            label = new Text()\n                .setPosition(this.getCenterPoint())\n                .setLabel(label)\n                .setOffset([0, -6])\n                .setFontStyle('');\n        return super.setLabel(label);\n    }\n\n    setLength(l) {\n        return (l > 0) ?\n            this.lineTo(['0D', l]) :\n            this.lineTo(['180D', -l])\n    }\n}"]},"metadata":{},"sourceType":"module"}