{"ast":null,"code":"import { Path } from \"../simple/path\";\nimport { Utils } from \"../../../tools/utils\";\nexport class WrapperPath extends Path {\n  constructor(handler) {\n    super();\n    this.handler = handler;\n  }\n\n  getLabel() {\n    let lbl = super.getLabel();\n    return lbl.label ? this.handler.generateShape(lbl).alignTo(this) : lbl;\n  }\n  /**\n   * offset can come after each point, then offset affects the that point<br/>\n   * quadratic can come before a line, then quadratic affects the proceeding line\n   * x,y: [x,y] or [intR,length] for radian, [intD,length] for degree or [shape,gap].<br/>\n   * ox,oy: [num,num]<br/>\n   *\n   * @param path\n   *      'm x y':moveTo([x,y])<br/>\n   *      'l x y':lineTo([x,y])<br/>\n   *      'q x y':quadraticTo([x,y])<br/>\n   *      'o ox oy':offset([ox,oy])<br/>\n   *\n   * @return {WrapperPath}\n   */\n\n\n  setPath(path) {\n    let arr = path.split(/ +/);\n    this.path = [];\n\n    for (let i = 0; i < arr.length; i++) {\n      switch (arr[i]) {\n        case 'm':\n          this.path.push({\n            m: 'moveTo',\n            args: [[this.getTargetShape(arr[i + 1]), Number(arr[i + 2])]]\n          });\n          break;\n\n        case 'o':\n          Utils.last(Utils.last(this.path).args).push(Number(arr[i + 1]), Number(arr[i + 2]));\n          break;\n\n        case 'q':\n          this.path.push({\n            m: 'quadraticTo',\n            args: [[this.getTargetShape(arr[i + 1]), Number(arr[i + 2])]]\n          });\n          break;\n\n        case 'l':\n          Utils.last(this.path).m === 'quadraticTo' ? Utils.last(this.path).args.push([this.getTargetShape(arr[i + 1]), Number(arr[i + 2])]) : this.path.push({\n            m: 'lineTo',\n            args: [[this.getTargetShape(arr[i + 1]), Number(arr[i + 2])]]\n          });\n          break;\n\n        default:\n          throw new Error('Wrong input');\n      }\n\n      i += 2;\n    }\n\n    return this;\n  }\n\n  getTargetShape(value) {\n    return typeof value === 'string' && !value.match('\\\\d+[dDrR]') ? this.handler.getTargetShape(value) : value;\n  }\n\n  moveTo(points) {\n    return super.moveTo(points[0]);\n  }\n\n  lineTo(points) {\n    return super.lineTo(points[0]);\n  }\n\n  quadraticTo(points) {\n    return super.quadraticTo(points[0], points[1]);\n  }\n\n  setType(type) {\n    this.setStrokeWidth(1);\n\n    switch (type) {\n      case 'ii':\n        this.setColor(\"green\");\n        this.showArrow(1, 1);\n        break;\n\n      case 'ci':\n        this.setColor(\"green\");\n        this.setStrokeStyle([10, 5]);\n        this.showArrow(1, 1);\n        break;\n\n      case 'cc':\n        this.setColor(\"blue\");\n        this.showArrow(1, 1);\n        break;\n\n      case 'c@':\n      case 'i@':\n        this.setColor(\"green\");\n        this.setStrokeStyle([3, 3]);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  render(canvasCtx) {\n    this.path.forEach(v => this[v.m](v.args));\n    super.render(canvasCtx);\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/wrappered/wrapper-path.js"],"names":["Path","Utils","WrapperPath","constructor","handler","getLabel","lbl","label","generateShape","alignTo","setPath","path","arr","split","i","length","push","m","args","getTargetShape","Number","last","Error","value","match","moveTo","points","lineTo","quadraticTo","setType","type","setStrokeWidth","setColor","showArrow","setStrokeStyle","render","canvasCtx","forEach","v"],"mappings":"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","sourcesContent":["import {Path} from \"../simple/path\";\nimport {Utils} from \"../../../tools/utils\";\n\nexport class WrapperPath extends Path {\n    constructor(handler) {\n        super();\n        this.handler = handler;\n    }\n\n    getLabel() {\n        let lbl = super.getLabel();\n        return (lbl.label) ? this.handler.generateShape(lbl).alignTo(this) : lbl;\n    }\n\n    /**\n     * offset can come after each point, then offset affects the that point<br/>\n     * quadratic can come before a line, then quadratic affects the proceeding line\n     * x,y: [x,y] or [intR,length] for radian, [intD,length] for degree or [shape,gap].<br/>\n     * ox,oy: [num,num]<br/>\n     *\n     * @param path\n     *      'm x y':moveTo([x,y])<br/>\n     *      'l x y':lineTo([x,y])<br/>\n     *      'q x y':quadraticTo([x,y])<br/>\n     *      'o ox oy':offset([ox,oy])<br/>\n     *\n     * @return {WrapperPath}\n     */\n    setPath(path) {\n        let arr = path.split(/ +/);\n        this.path = [];\n        for (let i = 0; i < arr.length; i++) {\n            switch (arr[i]) {\n                case 'm':\n                    this.path.push({m: 'moveTo', args: [[this.getTargetShape(arr[i + 1]), Number(arr[i + 2])]]});\n                    break;\n                case 'o':\n                    Utils.last(Utils.last(this.path).args).push(Number(arr[i + 1]), Number(arr[i + 2]));\n                    break;\n                case 'q':\n                    this.path.push({m: 'quadraticTo', args: [[this.getTargetShape(arr[i + 1]), Number(arr[i + 2])]]})\n                    break;\n                case 'l':\n                    Utils.last(this.path).m === 'quadraticTo' ?\n                        Utils.last(this.path).args.push([this.getTargetShape(arr[i + 1]), Number(arr[i + 2])]) :\n                        this.path.push({m: 'lineTo', args: [[this.getTargetShape(arr[i + 1]), Number(arr[i + 2])]]})\n                    break;\n                default:\n                    throw new Error('Wrong input')\n            }\n            i += 2;\n        }\n        return this;\n    }\n\n    getTargetShape(value) {\n        return (typeof value === 'string' && !value.match('\\\\d+[dDrR]')) ? this.handler.getTargetShape(value) : value;\n    }\n\n    moveTo(points) {\n        return super.moveTo(points[0]);\n    }\n\n    lineTo(points) {\n        return super.lineTo(points[0]);\n    }\n\n    quadraticTo(points) {\n        return super.quadraticTo(points[0], points[1]);\n    }\n\n    setType(type) {\n        this.setStrokeWidth(1);\n        switch (type) {\n            case 'ii':\n                this.setColor(\"green\");\n                this.showArrow(1, 1);\n                break;\n            case 'ci':\n                this.setColor(\"green\");\n                this.setStrokeStyle([10, 5]);\n                this.showArrow(1, 1);\n                break;\n            case 'cc':\n                this.setColor(\"blue\");\n                this.showArrow(1, 1);\n                break;\n            case 'c@':\n            case 'i@':\n                this.setColor(\"green\");\n                this.setStrokeStyle([3, 3]);\n                break;\n            default:\n                break;\n        }\n    }\n\n    render(canvasCtx) {\n        this.path.forEach(v => this[v.m](v.args));\n        super.render(canvasCtx);\n    }\n}"]},"metadata":{},"sourceType":"module"}