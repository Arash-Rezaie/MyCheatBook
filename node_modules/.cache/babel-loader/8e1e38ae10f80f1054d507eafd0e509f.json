{"ast":null,"code":"import { Shape } from \"./shape\";\nimport { Line } from \"./line\";\nexport class Path extends Shape {\n  constructor() {\n    super();\n    this.points = [];\n    this.setStrokeWidth(1);\n    this.offset2 = [0, 0];\n  }\n  /**\n   * @param point [x,y]\n   */\n\n\n  setStart(point) {\n    this.points[0] = point;\n    return this;\n  }\n  /**\n   * NOTICE TO KEEP AN SPACE BETWEEN EACH INPUT<br/>\n   *\n   * ox and oy are optional<br/>\n   * ox: offset x<br/>\n   * oy: offset y<br/><br/>\n   *\n   * input format:<br/>\n   *\n   * a pair of [x, y]:<br/>\n   *      [num, num] for exact location. ex: 12.5, 300<br/>\n   *      [numR, length] for radian, [numD, length] for degree. ex: [180d, 100] or [3.1415r, 100]<br/>\n   *      [shape, gap] for reference to a shape. ex: [new Circle()..., 10]<br/>\n   *\n   * a pair of [ox, oy]: [num, num]. ex: [15, 30]<br/>\n   *\n   * @param path 'm x y [ox oy]':moveTo(x, y, ox, oy), 'l x y [ox oy]':lineTo(x, y, ox, oy), 'q cx cy x y [ox oy]':quadraticTo(curveX, curveY, x, y, ox, oy)\n   */\n\n\n  setPath(path) {\n    let arr = path.split('/ +/g');\n    let l = arr.length;\n    let mem = null;\n\n    for (let i = 0; i < l; i++) {\n      switch (arr[i]) {\n        case 'm':\n          mem = {\n            p: [arr[i + 1], arr[i + 2]],\n            offset: this.getOffset(arr, i + 3)\n          };\n          i += mem.offset != null ? 4 : 2;\n          break;\n\n        case 'l':\n          i = this.createLine(arr, i, mem, false);\n          break;\n\n        case 'q':\n          i = this.createLine(arr, i, mem, true);\n          break;\n\n        default:\n          throw new Error('Wrong input');\n      }\n    }\n  }\n\n  createLine(arr, index, mem, isQ) {\n    //create new line\n    let l = new Line().setEnd(arr[index++], arr[index++]); //set line start\n\n    if (mem != null) {\n      l.setStart(mem.p);\n      l.setOffset(mem.offset);\n    } else {\n      l.setStart(this.points[this.points.length - 1].getEnd());\n    } //set line curve\n\n\n    if (isQ) {\n      l.setQuadraticPoint(arr[index++], arr[index++]);\n    } //set line offset2\n\n\n    let offset = this.getOffset(arr, index + 1);\n\n    if (offset != null) {\n      l.setOffset2(offset);\n      index += 2;\n    } //save this line\n\n\n    this.points.push({\n      line: l,\n      len: l.getLength()\n    }); //clear mem\n\n    mem = null;\n    return index;\n  }\n\n  getOffset(arr, index) {\n    let c = arr[index];\n    return c !== 'm' && c !== 'l' && c !== 'q' ? [c, arr[index + 1]] : null;\n  }\n  /**\n   * show arrows on the line\n   * @param direction 0 or 1\n   * @param places array of float values, each is 0 - 1;\n   * @return Shape\n   */\n\n\n  showArrow(direction, places) {\n    this.direction = direction;\n    this.places = typeof places === 'number' ? [places] : places;\n    return this;\n  }\n\n  render(canvasCtx) {\n    this.prepareLines();\n\n    for (let i = 1; i < this.points.length; i++) {\n      this.points[i].render(canvasCtx);\n    }\n  }\n\n  prepareLines() {\n    let lengths = [0]; // extract each line length to determine exact place of arrow\n    //prepare lines. connect lines to each other\n\n    this.points[1].setOffset(this.offset);\n    this.points[this.points.length - 1].setOffset2(this.offset2);\n    this.points[1].setStart(this.points[0]);\n    this.initLine(this.points[1]);\n    lengths.push(this.points[1].getLength());\n\n    for (let i = 2; i < this.points.length; i++) {\n      this.points[i].setStart(this.points[i - 1].getEnd());\n      this.initLine(this.points[i]);\n      lengths.push(lengths[i - 1] + this.points[i].getLength());\n    } //deter mine arrow position\n\n\n    if (this.places != null && this.places.length > 0) {\n      let repo = this.getDistributedArrowPlaces(lengths);\n\n      for (let k in repo) {\n        this.points[repo[k].key + 1].showArrow(this.direction, repo[k].items);\n      }\n    }\n  }\n\n  getDistributedArrowPlaces(lengths) {\n    let max = lengths[lengths.length - 1];\n    let p, temp;\n    let repo = [];\n\n    for (let i = 0; i < this.places.length; i++) {\n      p = this.places[i] * max;\n\n      for (let j = 0; j < lengths.length - 1; j++) {\n        if (p >= lengths[j] && p <= lengths[j + 1]) {\n          temp = this.getRepoObject(repo, j);\n          temp.items.push((p - lengths[j]) / (lengths[j + 1] - lengths[j]));\n          break;\n        }\n      }\n    }\n\n    return repo;\n  }\n\n  getRepoObject(repo, key) {\n    if (repo[key] == null) repo[key] = {\n      key: key,\n      items: [],\n      places: []\n    };\n    return repo[key];\n  }\n\n  initLine(line) {\n    line.setFillColor(this.fillColor);\n    line.setStrokeColor(this.strokeColor);\n    line.setStrokeWidth(this.strokeWidth);\n    line.setStrokeStyle(this.strokeStyle);\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/simple/path.js"],"names":["Shape","Line","Path","constructor","points","setStrokeWidth","offset2","setStart","point","setPath","path","arr","split","l","length","mem","i","p","offset","getOffset","createLine","Error","index","isQ","setEnd","setOffset","getEnd","setQuadraticPoint","setOffset2","push","line","len","getLength","c","showArrow","direction","places","render","canvasCtx","prepareLines","lengths","initLine","repo","getDistributedArrowPlaces","k","key","items","max","temp","j","getRepoObject","setFillColor","fillColor","setStrokeColor","strokeColor","strokeWidth","setStrokeStyle","strokeStyle"],"mappings":"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","sourcesContent":["import {Shape} from \"./shape\";\nimport {Line} from \"./line\";\n\nexport class Path extends Shape {\n    points = [];\n\n    constructor() {\n        super();\n        this.setStrokeWidth(1);\n        this.offset2 = [0, 0];\n    }\n\n    /**\n     * @param point [x,y]\n     */\n    setStart(point) {\n        this.points[0] = point;\n        return this;\n    }\n\n    /**\n     * NOTICE TO KEEP AN SPACE BETWEEN EACH INPUT<br/>\n     *\n     * ox and oy are optional<br/>\n     * ox: offset x<br/>\n     * oy: offset y<br/><br/>\n     *\n     * input format:<br/>\n     *\n     * a pair of [x, y]:<br/>\n     *      [num, num] for exact location. ex: 12.5, 300<br/>\n     *      [numR, length] for radian, [numD, length] for degree. ex: [180d, 100] or [3.1415r, 100]<br/>\n     *      [shape, gap] for reference to a shape. ex: [new Circle()..., 10]<br/>\n     *\n     * a pair of [ox, oy]: [num, num]. ex: [15, 30]<br/>\n     *\n     * @param path 'm x y [ox oy]':moveTo(x, y, ox, oy), 'l x y [ox oy]':lineTo(x, y, ox, oy), 'q cx cy x y [ox oy]':quadraticTo(curveX, curveY, x, y, ox, oy)\n     */\n    setPath(path) {\n        let arr = path.split('/ +/g');\n        let l = arr.length;\n        let mem = null;\n        for (let i = 0; i < l; i++) {\n            switch (arr[i]) {\n                case 'm':\n                    mem = {p: [arr[i + 1], arr[i + 2]], offset: this.getOffset(arr, i + 3)};\n                    i += (mem.offset != null) ? 4 : 2;\n                    break;\n                case 'l':\n                    i = this.createLine(arr, i, mem, false);\n                    break;\n                case 'q':\n                    i = this.createLine(arr, i, mem, true);\n                    break;\n                default:\n                    throw new Error('Wrong input')\n            }\n        }\n    }\n\n    createLine(arr, index, mem, isQ) {\n        //create new line\n        let l = new Line().setEnd(arr[index++], arr[index++]);\n\n        //set line start\n        if (mem != null) {\n            l.setStart(mem.p);\n            l.setOffset(mem.offset);\n        } else {\n            l.setStart(this.points[this.points.length - 1].getEnd());\n        }\n\n        //set line curve\n        if (isQ) {\n            l.setQuadraticPoint(arr[index++], arr[index++]);\n        }\n\n        //set line offset2\n        let offset = this.getOffset(arr, index + 1);\n        if (offset != null) {\n            l.setOffset2(offset);\n            index += 2;\n        }\n\n        //save this line\n        this.points.push({line: l, len: l.getLength()})\n\n        //clear mem\n        mem = null;\n\n        return index;\n    }\n\n    getOffset(arr, index) {\n        let c = arr[index];\n        return (c !== 'm' && c !== 'l' && c !== 'q') ? [c, arr[index + 1]] : null\n    }\n\n    /**\n     * show arrows on the line\n     * @param direction 0 or 1\n     * @param places array of float values, each is 0 - 1;\n     * @return Shape\n     */\n    showArrow(direction, places) {\n        this.direction = direction;\n        this.places = typeof places === 'number' ? [places] : places;\n        return this;\n    }\n\n    render(canvasCtx) {\n        this.prepareLines();\n        for (let i = 1; i < this.points.length; i++) {\n            this.points[i].render(canvasCtx);\n        }\n    }\n\n    prepareLines() {\n        let lengths = [0]; // extract each line length to determine exact place of arrow\n\n        //prepare lines. connect lines to each other\n        this.points[1].setOffset(this.offset);\n        this.points[this.points.length - 1].setOffset2(this.offset2);\n\n        this.points[1].setStart(this.points[0]);\n        this.initLine(this.points[1]);\n        lengths.push(this.points[1].getLength());\n\n        for (let i = 2; i < this.points.length; i++) {\n            this.points[i].setStart(this.points[i - 1].getEnd());\n            this.initLine(this.points[i]);\n            lengths.push(lengths[i - 1] + this.points[i].getLength());\n        }\n\n        //deter mine arrow position\n        if (this.places != null && this.places.length > 0) {\n            let repo = this.getDistributedArrowPlaces(lengths);\n            for (let k in repo) {\n                this.points[repo[k].key + 1].showArrow(this.direction, repo[k].items);\n            }\n        }\n    }\n\n    getDistributedArrowPlaces(lengths) {\n        let max = lengths[lengths.length - 1];\n        let p, temp;\n        let repo = [];\n        for (let i = 0; i < this.places.length; i++) {\n            p = this.places[i] * max;\n            for (let j = 0; j < lengths.length - 1; j++) {\n                if (p >= lengths[j] && p <= lengths[j + 1]) {\n                    temp = this.getRepoObject(repo, j);\n                    temp.items.push((p - lengths[j]) / (lengths[j + 1] - lengths[j]));\n                    break;\n                }\n            }\n        }\n        return repo;\n    }\n\n    getRepoObject(repo, key) {\n        if (repo[key] == null)\n            repo[key] = {key: key, items: [], places: []};\n        return repo[key];\n    }\n\n    initLine(line) {\n        line.setFillColor(this.fillColor);\n        line.setStrokeColor(this.strokeColor);\n        line.setStrokeWidth(this.strokeWidth);\n        line.setStrokeStyle(this.strokeStyle);\n    }\n}"]},"metadata":{},"sourceType":"module"}