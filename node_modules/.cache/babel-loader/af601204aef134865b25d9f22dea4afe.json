{"ast":null,"code":"import { Utils } from \"../../../tools/utils\";\nimport { Shape } from \"./shape\";\n\nclass Point {\n  constructor(initValues) {\n    this.offset = [0, 0];\n    this.pos = initValues;\n  }\n\n  setOffset(offsetX = 0, offsetY = 0) {\n    this.offset = [offsetX, offsetY];\n  }\n\n  locateByPoint(point) {\n    this.pos[0] += this.offset[0];\n    this.pos[1] += this.offset[1];\n  }\n\n  getPosition() {\n    return this.pos;\n  }\n\n  getAnchorPointByAngle(angle) {\n    return this.pos;\n  }\n\n  getAnchorPointByPoint(point) {\n    return this.pos;\n  }\n\n  locateAnchor(...points) {}\n\n  applyShapeOffset(shapeOffset) {\n    this.pos[0] += shapeOffset[0];\n    this.pos[1] += shapeOffset[1];\n  }\n\n  getAnchor() {\n    return this.pos;\n  }\n\n}\n\nclass AnglePoint extends Point {\n  constructor(initValues) {\n    super();\n    let i = initValues[0].length - 1;\n    let c = initValues[0][i];\n    let v = Number(initValues[0].substring(0, i));\n\n    if (c === 'R' || c === 'r') {\n      this.angle = Utils.normalizeRadian(v);\n      this.distance = initValues[1];\n    } else if (c === 'D' || c === 'd') {\n      this.angle = Utils.normalizeRadian(Utils.deg2Rad(v));\n      this.distance = initValues[1];\n    } else {\n      throw new Error('wrong input');\n    }\n  }\n\n  locateByPoint(point) {\n    let anchor = point.getAnchorPointByAngle(this.angle);\n    this.pos = Utils.getPointByAngle(anchor, this.angle, this.distance);\n    super.locateByPoint(point);\n  }\n\n}\n\nclass ShapePoint extends Point {\n  constructor(initValues) {\n    super();\n    this.shape = initValues[0];\n    this.gap = initValues[1];\n    this.cache = []; //item sample: [angles] => {points: [p], anchor: a}\n  }\n\n  locateByPoint(point) {\n    this.pos = this.shape.getCenterPoint();\n    super.locateByPoint(point);\n  }\n\n  getAnchorPointByAngle(angle) {\n    if (this.cache[angle] == null) {\n      let p = {\n        'pos': this.shape.getExternalPoint(angle, this.gap)\n      };\n      this.cache[angle]['pos'][0] += this.offset[0];\n      this.cache[angle]['pos'][1] += this.offset[1];\n      this.cache[angle]['pos'][1] += this.offset[1];\n    }\n\n    return this.cache[angle]['pos'];\n  }\n\n  getAnchorPointByPoint(point) {\n    let angle = this.cachePointAndGetAngle(point);\n    return this.cache[angle]['pos'];\n  }\n\n  cachePointAndGetAngle(point) {\n    let angle = this.searchCacheByPoint(point); //catch the angle\n\n    if (angle == null) {\n      angle = Utils.getAngleByPoint(this.shape.getCenterPoint(), point.getPosition()); //store angle-pos pair\n\n      this.getAnchorPointByAngle(angle);\n    } //store angle-point pair\n\n\n    this.cache[angle]['point'] = point;\n    return angle;\n  }\n\n  searchCacheByPoint(point) {\n    for (let k in this.cache) if (this.cache[k]['point'] === point) return k;\n  }\n\n  getAvgAngle(angles) {\n    let avg = angles[0];\n\n    for (let i = 1; i < angles.length; i++) {\n      let midAngle = (avg + angles[i]) / 2;\n      if (Math.abs(avg - angles[i]) > Math.PI) //if angle1 - angle3 > 180deg => correct mid angle\n        midAngle = Utils.reverseRad(midAngle);\n      avg = midAngle;\n    }\n\n    return avg;\n  }\n\n  locateAnchor(...points) {\n    let angles = [];\n    points.forEach(v => angles.push(this.cachePointAndGetAngle(v)));\n    if (angles.length > 1) angles = this.getAvgAngle(angles);\n    this.anchor = this.getAnchorPointByAngle(angles);\n  }\n\n  applyShapeOffset(shapeOffset) {\n    this.anchor[0] += shapeOffset[0];\n    this.anchor[1] += shapeOffset[1];\n  }\n\n  getAnchor() {\n    return this.anchor;\n  }\n\n}\n\nexport class Line extends Shape {\n  constructor() {\n    super();\n    this.processed = false;\n    this.setStrokeWidth(1);\n  }\n\n  setPosition(position) {\n    if (typeof position[0] === 'string') throw new Error('Wrong input');\n    this.start = this.getPointObject(position);\n    return this;\n  }\n\n  setStart(point) {\n    return this.setPosition(point);\n  }\n\n  setEnd(point) {\n    this.end = this.getPointObject(point);\n    return this;\n  }\n\n  setQuadraticPoint(point) {\n    this.qCurve = this.getPointObject(point);\n    return this;\n  }\n  /**\n   * @param point [x,y,ox,oy] or [intR,length,ox,oy] for radian, [intD,length,ox,oy] for degree or [shape,gap,ox,oy].<br/>\n   */\n\n\n  getPointObject(point) {\n    let p;\n\n    switch (this.getTypeOf(point)) {\n      case \"number\":\n        //[x,y]\n        p = new Point(point);\n        p.setOffset(point[2], point[3]);\n        return p;\n\n      case \"string\":\n        //[intR,length] or [intD,length]\n        p = new AnglePoint(point);\n        p.setOffset(point[2], point[3]);\n        return p;\n\n      case \"object\":\n        //[shape,gap]\n        p = new ShapePoint(point);\n        p.setOffset(point[2], point[3]);\n        return p;\n\n      default:\n        throw new Error('wrong input');\n    }\n  }\n\n  getTypeOf(point) {\n    return typeof point[0];\n  }\n\n  render(canvasCtx) {\n    this.preparePoints();\n    let ps = this.start.getAnchor();\n    let pe = this.end.getAnchor();\n    canvasCtx.beginPath();\n    canvasCtx.fillStyle = 'transparent';\n    canvasCtx.moveTo(ps[0], ps[1]);\n\n    if (this.qCurve) {\n      let p2 = this.qCurve.getAnchor();\n      canvasCtx.quadraticCurveTo(p2[0], p2[1], pe[0], pe[1]);\n    } else {\n      canvasCtx.lineTo(pe[0], pe[1]);\n    }\n\n    this.fillColor2 = this.fillColor;\n    this.fillColor = undefined;\n    super.render(canvasCtx);\n    this.fillColor = this.fillColor2;\n    this.setStrokeStyle([1, 0]);\n\n    if (this.direction !== undefined && this.places !== undefined) {\n      let info = this.getArrowInfo();\n      let x, y;\n\n      for (let i = 0; i < info.length; i++) {\n        x = ps[0] + (pe[0] - ps[0]) * info[i][0];\n        y = ps[1] + (pe[1] - ps[1]) * info[i][0];\n        this.drawArrow(canvasCtx, 10, info[i][1], x, y);\n      }\n    }\n  }\n\n  preparePoints() {\n    if (!this.processed) {\n      if (this.start.offset[0] === -30) debugger; //locate start\n\n      this.start.locateByPoint(); //locate end\n\n      this.end.locateByPoint(this.start); //locate connection points. In here it is called anchor point\n\n      if (this.qCurve != null) {\n        this.qCurve.locateByPoint(this.start);\n        this.qCurve.locateAnchor(this.start, this.end);\n        this.end.locateAnchor(this.qCurve);\n        this.start.locateAnchor(this.qCurve);\n      } else {\n        this.end.locateAnchor(this.start);\n        this.start.locateAnchor(this.end);\n      } //apply shape offset\n\n\n      this.start.applyShapeOffset(this.offset);\n      this.end.applyShapeOffset(this.offset);\n      if (this.qCurve != null) this.qCurve.applyShapeOffset(this.offset);\n      this.processed = true;\n    }\n  }\n\n  getCenterPoint() {\n    this.preparePoints();\n    let s = this.start.getAnchor();\n    let e = this.end.getAnchor();\n    return [(s[0] + e[0]) / 2, (s[1] + e[1]) / 2];\n  }\n  /**\n   * show arrows on the line\n   * @param direction 0 or 1\n   * @param places array of float values, each is 0 - 1;\n   * @return Shape\n   */\n\n\n  showArrow(direction, places) {\n    this.direction = direction;\n    this.places = places;\n    return this;\n  }\n\n  drawArrow(canvasCtx, length, angle, x, y) {\n    canvasCtx.beginPath();\n    let p1 = [x - length * Math.cos(angle - Utils._PI6), y - length * Math.sin(angle - Utils._PI6)];\n    let p2 = [x - length * Math.cos(angle + Utils._PI6), y - length * Math.sin(angle + Utils._PI6)];\n    canvasCtx.moveTo(x, y);\n    canvasCtx.lineTo(p1[0], p1[1]);\n    canvasCtx.lineTo(p2[0], p2[1]);\n    canvasCtx.closePath();\n    super.render(canvasCtx);\n  }\n\n  getArrowInfo() {\n    let ans = [];\n    if (typeof this.places === 'number') this.places = [this.places];\n\n    if (this.qCurve != null) {\n      this.places = this.shrinkTo01(this.places);\n      this.places.forEach(v => ans.push([v, this.getArrowAngleForQCurve(v)]));\n    } else {\n      let angle = this.direction ? Utils.getAngleByPoint(this.start.getAnchor(), this.end.getAnchor()) : Utils.getAngleByPoint(this.end.getAnchor(), this.start.getAnchor());\n      this.places.forEach(v => ans.push([v, angle]));\n    }\n\n    return ans;\n  }\n\n  getArrowAngleForQCurve(place) {\n    if (this.direction) {\n      return place <= 0.5 ? Utils.getAngleByPoint(this.start.getAnchor(), this.qCurve.getAnchor()) : Utils.getAngleByPoint(this.qCurve.getAnchor(), this.end.getAnchor());\n    } else {\n      return place <= 0.5 ? Utils.getAngleByPoint(this.qCurve.getAnchor(), this.start.getAnchor()) : Utils.getAngleByPoint(this.end.getAnchor(), this.qCurve.getAnchor());\n    }\n  }\n\n  shrinkTo01(a) {\n    let ans = [];\n    a.forEach(v => v <= 0.5 ? ans[0] = 0 : ans[1] = 1);\n    return ans[0] == null ? [1] : ans;\n  }\n\n  getStart() {\n    this.preparePoints();\n    return this.start.getAnchor();\n  }\n\n  getEnd() {\n    this.preparePoints();\n    return this.end.getAnchor();\n  }\n\n  getLength() {\n    this.preparePoints();\n    return Utils.getLengthByPoints(this.start.getAnchor(), this.end.getAnchor());\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/simple/line.js"],"names":["Utils","Shape","Point","constructor","initValues","offset","pos","setOffset","offsetX","offsetY","locateByPoint","point","getPosition","getAnchorPointByAngle","angle","getAnchorPointByPoint","locateAnchor","points","applyShapeOffset","shapeOffset","getAnchor","AnglePoint","i","length","c","v","Number","substring","normalizeRadian","distance","deg2Rad","Error","anchor","getPointByAngle","ShapePoint","shape","gap","cache","getCenterPoint","p","getExternalPoint","cachePointAndGetAngle","searchCacheByPoint","getAngleByPoint","k","getAvgAngle","angles","avg","midAngle","Math","abs","PI","reverseRad","forEach","push","Line","processed","setStrokeWidth","setPosition","position","start","getPointObject","setStart","setEnd","end","setQuadraticPoint","qCurve","getTypeOf","render","canvasCtx","preparePoints","ps","pe","beginPath","fillStyle","moveTo","p2","quadraticCurveTo","lineTo","fillColor2","fillColor","undefined","setStrokeStyle","direction","places","info","getArrowInfo","x","y","drawArrow","s","e","showArrow","p1","cos","_PI6","sin","closePath","ans","shrinkTo01","getArrowAngleForQCurve","place","a","getStart","getEnd","getLength","getLengthByPoints"],"mappings":"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","sourcesContent":["import {Utils} from \"../../../tools/utils\";\nimport {Shape} from \"./shape\";\n\nclass Point {\n    pos;\n    offset = [0, 0];\n\n    constructor(initValues) {\n        this.pos = initValues;\n    }\n\n    setOffset(offsetX = 0, offsetY = 0) {\n        this.offset = [offsetX, offsetY];\n    }\n\n    locateByPoint(point) {\n        this.pos[0] += this.offset[0];\n        this.pos[1] += this.offset[1];\n    }\n\n    getPosition() {\n        return this.pos;\n    }\n\n    getAnchorPointByAngle(angle) {\n        return this.pos;\n    }\n\n    getAnchorPointByPoint(point) {\n        return this.pos;\n    }\n\n    locateAnchor(...points) {\n    }\n\n    applyShapeOffset(shapeOffset) {\n        this.pos[0] += shapeOffset[0];\n        this.pos[1] += shapeOffset[1];\n    }\n\n    getAnchor() {\n        return this.pos;\n    }\n}\n\nclass AnglePoint extends Point {\n    constructor(initValues) {\n        super();\n        let i = initValues[0].length - 1;\n        let c = initValues[0][i];\n        let v = Number(initValues[0].substring(0, i));\n        if (c === 'R' || c === 'r') {\n            this.angle = Utils.normalizeRadian(v);\n            this.distance = initValues[1];\n        } else if (c === 'D' || c === 'd') {\n            this.angle = Utils.normalizeRadian(Utils.deg2Rad(v));\n            this.distance = initValues[1];\n        } else {\n            throw new Error('wrong input');\n        }\n    }\n\n    locateByPoint(point) {\n        let anchor = point.getAnchorPointByAngle(this.angle);\n        this.pos = Utils.getPointByAngle(anchor, this.angle, this.distance);\n        super.locateByPoint(point);\n    }\n}\n\nclass ShapePoint extends Point {\n    constructor(initValues) {\n        super();\n        this.shape = initValues[0];\n        this.gap = initValues[1];\n        this.cache = [];//item sample: [angles] => {points: [p], anchor: a}\n    }\n\n    locateByPoint(point) {\n        this.pos = this.shape.getCenterPoint();\n        super.locateByPoint(point);\n    }\n\n    getAnchorPointByAngle(angle) {\n        if (this.cache[angle] == null) {\n            let p = {'pos': this.shape.getExternalPoint(angle, this.gap)};\n            this.cache[angle]['pos'][0] += this.offset[0];\n            this.cache[angle]['pos'][1] += this.offset[1];\n            this.cache[angle]['pos'][1] += this.offset[1];\n        }\n        return this.cache[angle]['pos'];\n    }\n\n    getAnchorPointByPoint(point) {\n        let angle = this.cachePointAndGetAngle(point);\n        return this.cache[angle]['pos'];\n    }\n\n    cachePointAndGetAngle(point) {\n        let angle = this.searchCacheByPoint(point);\n\n        //catch the angle\n        if (angle == null) {\n            angle = Utils.getAngleByPoint(this.shape.getCenterPoint(), point.getPosition());\n\n            //store angle-pos pair\n            this.getAnchorPointByAngle(angle);\n        }\n\n        //store angle-point pair\n        this.cache[angle]['point'] = point;\n\n        return angle;\n    }\n\n    searchCacheByPoint(point) {\n        for (let k in this.cache)\n            if (this.cache[k]['point'] === point)\n                return k;\n    }\n\n    getAvgAngle(angles) {\n        let avg = angles[0];\n        for (let i = 1; i < angles.length; i++) {\n            let midAngle = (avg + angles[i]) / 2;\n            if (Math.abs(avg - angles[i]) > Math.PI) //if angle1 - angle3 > 180deg => correct mid angle\n                midAngle = Utils.reverseRad(midAngle);\n            avg = midAngle;\n        }\n        return avg;\n    }\n\n    locateAnchor(...points) {\n        let angles = [];\n        points.forEach(v => angles.push(this.cachePointAndGetAngle(v)));\n        if (angles.length > 1)\n            angles = this.getAvgAngle(angles);\n        this.anchor = this.getAnchorPointByAngle(angles);\n    }\n\n    applyShapeOffset(shapeOffset) {\n        this.anchor[0] += shapeOffset[0];\n        this.anchor[1] += shapeOffset[1];\n    }\n\n    getAnchor() {\n        return this.anchor;\n    }\n}\n\nexport class Line extends Shape {\n    start;\n    end;\n    qCurve;\n    processed = false;\n\n    constructor() {\n        super();\n        this.setStrokeWidth(1);\n    }\n\n    setPosition(position) {\n        if (typeof position[0] === 'string')\n            throw new Error('Wrong input')\n        this.start = this.getPointObject(position);\n        return this;\n    }\n\n    setStart(point) {\n        return this.setPosition(point);\n    }\n\n    setEnd(point) {\n        this.end = this.getPointObject(point);\n        return this;\n    }\n\n    setQuadraticPoint(point) {\n        this.qCurve = this.getPointObject(point);\n        return this;\n    }\n\n    /**\n     * @param point [x,y,ox,oy] or [intR,length,ox,oy] for radian, [intD,length,ox,oy] for degree or [shape,gap,ox,oy].<br/>\n     */\n    getPointObject(point) {\n        let p;\n        switch (this.getTypeOf(point)) {\n            case \"number\"://[x,y]\n                p = new Point(point);\n                p.setOffset(point[2], point[3]);\n                return p;\n            case \"string\"://[intR,length] or [intD,length]\n                p = new AnglePoint(point);\n                p.setOffset(point[2], point[3]);\n                return p;\n            case \"object\"://[shape,gap]\n                p = new ShapePoint(point);\n                p.setOffset(point[2], point[3]);\n                return p;\n            default:\n                throw new Error('wrong input');\n        }\n    }\n\n    getTypeOf(point) {\n        return typeof point[0]\n    }\n\n    render(canvasCtx) {\n        this.preparePoints();\n        let ps = this.start.getAnchor();\n        let pe = this.end.getAnchor();\n\n        canvasCtx.beginPath();\n        canvasCtx.fillStyle = 'transparent';\n        canvasCtx.moveTo(ps[0], ps[1]);\n        if (this.qCurve) {\n            let p2 = this.qCurve.getAnchor();\n            canvasCtx.quadraticCurveTo(p2[0], p2[1], pe[0], pe[1]);\n        } else {\n            canvasCtx.lineTo(pe[0], pe[1]);\n        }\n\n        this.fillColor2 = this.fillColor;\n        this.fillColor = undefined;\n        super.render(canvasCtx);\n        this.fillColor = this.fillColor2;\n        this.setStrokeStyle([1, 0]);\n        if (this.direction !== undefined && this.places !== undefined) {\n            let info = this.getArrowInfo();\n            let x, y;\n            for (let i = 0; i < info.length; i++) {\n                x = ps[0] + (pe[0] - ps[0]) * info[i][0];\n                y = ps[1] + (pe[1] - ps[1]) * info[i][0];\n                this.drawArrow(canvasCtx, 10, info[i][1], x, y);\n            }\n        }\n    }\n\n    preparePoints() {\n        if (!this.processed) {\n            if (this.start.offset[0] === -30)\n                debugger\n            //locate start\n            this.start.locateByPoint();\n\n            //locate end\n            this.end.locateByPoint(this.start);\n\n            //locate connection points. In here it is called anchor point\n            if (this.qCurve != null) {\n                this.qCurve.locateByPoint(this.start);\n                this.qCurve.locateAnchor(this.start, this.end);\n                this.end.locateAnchor(this.qCurve);\n                this.start.locateAnchor(this.qCurve);\n            } else {\n                this.end.locateAnchor(this.start);\n                this.start.locateAnchor(this.end);\n            }\n\n            //apply shape offset\n            this.start.applyShapeOffset(this.offset);\n            this.end.applyShapeOffset(this.offset);\n            if (this.qCurve != null)\n                this.qCurve.applyShapeOffset(this.offset);\n\n            this.processed = true;\n        }\n    }\n\n    getCenterPoint() {\n        this.preparePoints();\n        let s = this.start.getAnchor();\n        let e = this.end.getAnchor();\n        return [(s[0] + e[0]) / 2, (s[1] + e[1]) / 2]\n    }\n\n    /**\n     * show arrows on the line\n     * @param direction 0 or 1\n     * @param places array of float values, each is 0 - 1;\n     * @return Shape\n     */\n    showArrow(direction, places) {\n        this.direction = direction;\n        this.places = places;\n        return this;\n    }\n\n    drawArrow(canvasCtx, length, angle, x, y) {\n        canvasCtx.beginPath();\n        let p1 = [x - length * Math.cos(angle - Utils._PI6), y - length * Math.sin(angle - Utils._PI6)];\n        let p2 = [x - length * Math.cos(angle + Utils._PI6), y - length * Math.sin(angle + Utils._PI6)];\n        canvasCtx.moveTo(x, y);\n        canvasCtx.lineTo(p1[0], p1[1]);\n        canvasCtx.lineTo(p2[0], p2[1]);\n        canvasCtx.closePath();\n        super.render(canvasCtx);\n    }\n\n    getArrowInfo() {\n        let ans = [];\n\n        if (typeof this.places === 'number')\n            this.places = [this.places];\n\n        if (this.qCurve != null) {\n            this.places = this.shrinkTo01(this.places);\n            this.places.forEach(v => ans.push([v, this.getArrowAngleForQCurve(v)]));\n        } else {\n            let angle = this.direction ?\n                Utils.getAngleByPoint(this.start.getAnchor(), this.end.getAnchor()) :\n                Utils.getAngleByPoint(this.end.getAnchor(), this.start.getAnchor());\n            this.places.forEach(v => ans.push([v, angle]));\n        }\n        return ans;\n    }\n\n    getArrowAngleForQCurve(place) {\n        if (this.direction) {\n            return place <= 0.5 ?\n                Utils.getAngleByPoint(this.start.getAnchor(), this.qCurve.getAnchor()) :\n                Utils.getAngleByPoint(this.qCurve.getAnchor(), this.end.getAnchor());\n        } else {\n            return place <= 0.5 ?\n                Utils.getAngleByPoint(this.qCurve.getAnchor(), this.start.getAnchor()) :\n                Utils.getAngleByPoint(this.end.getAnchor(), this.qCurve.getAnchor());\n        }\n    }\n\n    shrinkTo01(a) {\n        let ans = [];\n        a.forEach(v => v <= 0.5 ? ans[0] = 0 : ans[1] = 1);\n        return ans[0] == null ? [1] : ans;\n    }\n\n    getStart() {\n        this.preparePoints();\n        return this.start.getAnchor();\n    }\n\n    getEnd() {\n        this.preparePoints();\n        return this.end.getAnchor();\n    }\n\n    getLength() {\n        this.preparePoints();\n        return Utils.getLengthByPoints(this.start.getAnchor(), this.end.getAnchor());\n    }\n}"]},"metadata":{},"sourceType":"module"}