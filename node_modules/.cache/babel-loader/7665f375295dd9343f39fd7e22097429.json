{"ast":null,"code":"import { Shape } from \"./shape\";\nimport { Line } from \"./line\";\nexport class Path extends Shape {\n  constructor() {\n    super();\n    this.points = [];\n    this.setStrokeWidth(1);\n  }\n  /**\n   * @param point [x,y]\n   */\n\n\n  setStart(point) {\n    this.setPosition(point);\n    this.points[0] = point;\n    return this;\n  }\n  /**\n   * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n   */\n\n\n  lineTo(point) {\n    this.points.push(new Line().setEnd(point));\n    return this;\n  }\n  /**\n   * @param curve [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n   * @param end [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n   */\n\n\n  quadraticTo(curve, end) {\n    this.points.push(new Line().setQuadraticPoint(curve).setEnd(end));\n    return this;\n  }\n  /**\n   * show arrows on the line\n   * @param direction 0 or 1\n   * @param places array of float values, each is 0 - 1;\n   * @return Shape\n   */\n\n\n  showArrow(direction, places) {\n    this.direction = direction;\n    this.places = typeof places === 'number' ? [places] : places;\n    return this;\n  }\n\n  render(canvasCtx) {\n    this.prepareLines();\n\n    for (let i = 1; i < this.points.length; i++) {\n      this.points[i].render(canvasCtx);\n    }\n  }\n\n  prepareLines() {\n    debugger;\n    let length = []; // extract each line length to determine exact place of arrow\n    //prepare lines. connect lines to each other\n\n    this.points[0] = this.getPosition();\n    this.points[1].setStart(this.points[0]);\n    this.initLine(this.points[1]);\n    length.push(this.points[0].getLength());\n\n    for (let i = 2; i < this.points.length; i++) {\n      this.points[i].setStart(this.points[i - 1].getEnd());\n      this.initLine(this.points[i]);\n      length.push(length[i - 2] + this.points[i].getLength());\n    } //deter mine arrow position\n\n\n    let repo = this.getDistributedArrowPlaces(length);\n\n    for (let k in repo) {\n      this.points[k + 1].showArrow(this.direction, repo[k].items);\n    }\n  }\n\n  getDistributedArrowPlaces(length) {\n    let temp = length[length.length - 1];\n    let places = [];\n    this.places.forEach(v => places.push(v * temp));\n    let repo = [];\n\n    for (let i = 0; i < places.length - 1; i++) {\n      if (places[i] > length[i] && places[i] < length[i + 1]) {\n        temp = this.getRepoObject(repo, i);\n        temp.items.push(places[i] / length[i]);\n      }\n    }\n\n    return repo;\n  }\n\n  getRepoObject(repo, key) {\n    if (repo[key] == null) {\n      repo[key] = {\n        key: key,\n        items: []\n      };\n    }\n\n    return repo[key];\n  }\n\n  initLine(line) {\n    line.setFillColor(this.fillColor);\n    line.setStrokeColor(this.strokeColor);\n    line.setStrokeWidth(this.strokeWidth);\n    line.setStrokeStyle(this.strokeStyle);\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/simple/path.js"],"names":["Shape","Line","Path","constructor","points","setStrokeWidth","setStart","point","setPosition","lineTo","push","setEnd","quadraticTo","curve","end","setQuadraticPoint","showArrow","direction","places","render","canvasCtx","prepareLines","i","length","getPosition","initLine","getLength","getEnd","repo","getDistributedArrowPlaces","k","items","temp","forEach","v","getRepoObject","key","line","setFillColor","fillColor","setStrokeColor","strokeColor","strokeWidth","setStrokeStyle","strokeStyle"],"mappings":"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","sourcesContent":["import {Shape} from \"./shape\";\nimport {Line} from \"./line\";\n\nexport class Path extends Shape {\n    points = [];\n\n    constructor() {\n        super();\n        this.setStrokeWidth(1);\n    }\n\n    /**\n     * @param point [x,y]\n     */\n    setStart(point) {\n        this.setPosition(point);\n        this.points[0] = point;\n        return this;\n    }\n\n    /**\n     * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n     */\n    lineTo(point) {\n        this.points.push(new Line().setEnd(point));\n        return this;\n    }\n\n    /**\n     * @param curve [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n     * @param end [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n     */\n    quadraticTo(curve, end) {\n        this.points.push(new Line().setQuadraticPoint(curve).setEnd(end));\n        return this;\n    }\n\n    /**\n     * show arrows on the line\n     * @param direction 0 or 1\n     * @param places array of float values, each is 0 - 1;\n     * @return Shape\n     */\n    showArrow(direction, places) {\n        this.direction = direction;\n        this.places = typeof places === 'number' ? [places] : places;\n        return this;\n    }\n\n    render(canvasCtx) {\n        this.prepareLines();\n        for (let i = 1; i < this.points.length; i++) {\n            this.points[i].render(canvasCtx);\n        }\n    }\n\n    prepareLines() {\n        debugger\n        let length = []; // extract each line length to determine exact place of arrow\n\n        //prepare lines. connect lines to each other\n        this.points[0] = this.getPosition();\n\n        this.points[1].setStart(this.points[0]);\n        this.initLine(this.points[1]);\n        length.push(this.points[0].getLength());\n\n        for (let i = 2; i < this.points.length; i++) {\n            this.points[i].setStart(this.points[i - 1].getEnd());\n            this.initLine(this.points[i]);\n            length.push(length[i - 2] + this.points[i].getLength());\n        }\n\n        //deter mine arrow position\n        let repo = this.getDistributedArrowPlaces(length);\n        for (let k in repo) {\n            this.points[k + 1].showArrow(this.direction, repo[k].items);\n        }\n    }\n\n    getDistributedArrowPlaces(length) {\n        let temp = length[length.length - 1];\n        let places = [];\n        this.places.forEach(v => places.push(v * temp));\n\n        let repo = [];\n        for (let i = 0; i < places.length - 1; i++) {\n            if (places[i] > length[i] && places[i] < length[i + 1]) {\n                temp = this.getRepoObject(repo, i);\n                temp.items.push(places[i] / length[i]);\n            }\n        }\n        return repo;\n    }\n\n    getRepoObject(repo, key) {\n        if (repo[key] == null) {\n            repo[key] = {key: key, items: []};\n        }\n        return repo[key];\n    }\n\n    initLine(line) {\n        line.setFillColor(this.fillColor);\n        line.setStrokeColor(this.strokeColor);\n        line.setStrokeWidth(this.strokeWidth);\n        line.setStrokeStyle(this.strokeStyle);\n    }\n}"]},"metadata":{},"sourceType":"module"}