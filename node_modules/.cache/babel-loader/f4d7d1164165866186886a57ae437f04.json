{"ast":null,"code":"import { Shape } from \"./shape\";\nimport { Utils } from \"../../../tools/utils\";\nimport { Text } from \"./text\";\nexport class Line extends Shape {\n  constructor() {\n    super();\n    this.path = [];\n    this.setStrokeWidth(1);\n  }\n\n  setPosition(position) {\n    return this.addPoint(position, 0);\n  }\n\n  addPoint(point, index = null) {\n    if (index == null) {\n      this.path.push(this.getPoint(point));\n    } else {\n      for (let i = this.path.length; i > index; i--) this.path[i] = this.path[i - 1];\n\n      this.path[index] = this.getPoint(point);\n    }\n\n    return this;\n  }\n  /**\n   * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n   * you can have m & n before point location to make the line curvy:<br/>\n   * ex.<br/>\n   * [4, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [4, 5] in curvy shape<br/>\n   * [90d, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [90d, 5] in curvy shape<br/>\n   * [1r, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [1r, 5] in curvy shape<br/>\n   * [shape, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [shape, 5] in curvy shape<br/>\n   *\n   */\n\n\n  getPoint(point) {\n    let ans = {};\n    let p, c;\n\n    if (point[2] != null && point[3] != null) {\n      p = [point[2], point[3]];\n      c = [point[0], point[1]];\n    } else {\n      p = [point[0], point[1]];\n    }\n\n    switch (this.getTypeOf(p)) {\n      case \"number,number\":\n        //[x,y]\n        ans[\"xy\"] = p;\n        break;\n\n      case \"string,number\":\n        //[intR,length] or [intD,length]\n        let i = p[0].length - 1;\n        let c = p[0][i];\n        let v = Number(p[0].substring(0, i));\n\n        if (c === 'R' || c === 'r') {\n          ans[\"angle\"] = Utils.normalizeRadian(v);\n          ans[\"gap\"] = p[1];\n        } else if (c === 'D' || c === 'd') {\n          ans[\"angle\"] = Utils.normalizeRadian(Utils.deg2Rad(v));\n          ans[\"gap\"] = p[1];\n        } else {\n          throw new Error('wrong input');\n        }\n\n        break;\n\n      case \"object,number\":\n        //[shape,gap]\n        ans[\"shape\"] = p[0];\n        ans[\"gap\"] = p[1];\n        break;\n\n      default:\n        throw new Error('wrong input');\n    }\n\n    if (c != null) {\n      ans[\"curve\"] = this.getPoint(c);\n    }\n\n    return ans;\n  }\n\n  getTypeOf(point) {\n    return typeof point[0] + ',' + typeof point[1];\n  }\n\n  render(canvasCtx) {\n    this.preparePoints();\n    canvasCtx.beginPath();\n    let p = this.path[0];\n    canvasCtx.moveTo(p[\"xy\"][0], p[\"xy\"][1]);\n\n    for (let i = 1; i < this.path.length; i++) {\n      p = this.path[i];\n      if (p[\"curve\"] != null) canvasCtx.quadraticCurveTo(p[\"curve\"][\"xy\"][0], p[\"curve\"][\"xy\"][1], p[\"xy\"][0], p[\"xy\"][1]);else canvasCtx.lineTo(p[\"xy\"][0], p[\"xy\"][1]);\n    } // canvasCtx.closePath();\n\n\n    super.render(canvasCtx);\n  }\n\n  preparePoints() {\n    debugger;\n\n    for (let i = 1; i < this.path.length; i++) {\n      if (this.path[i][\"curve\"] != null) this.process3PointsXY(this.path[i - 1], this.path[\"curve\"], this.path[i]);else this.process2PointsXY(this.path[i - 1], this.path[i]);\n    }\n  }\n\n  process2PointsXY(p1, p2, ignoreP1XYModification = false) {\n    let angle;\n\n    if (p2[\"xy\"] == null) {\n      let c1 = p1[\"xy\"] != null ? p1[\"xy\"] : p1[\"shape\"].getCenterPoint();\n\n      if (p2[\"angle\"] != null) {\n        angle = p2[\"angle\"];\n        p2[\"xy\"] = Utils.getPointByAngle(c1, angle, p2[\"gap\"]);\n      } else if (p2[\"shape\"] != null) {\n        let c2 = p2[\"shape\"].getCenterPoint();\n        angle = Utils.getAngle(c2[0], c2[1], c1[0], c1[1]);\n        p2[\"xy\"] = this.getTargetXY(p2, angle);\n      } else {\n        throw new Error(\"no way to calculate point.xy\");\n      }\n    }\n\n    if (!ignoreP1XYModification && p1[\"xy\"] == null) {\n      p1[\"xy\"] = this.getTargetXY(p1, Math.PI - angle);\n    }\n  } //p must be a shape\n\n\n  getTargetXY(p, angle) {\n    return p[\"shape\"][\"getExternalPoint\"] != null ? p[\"shape\"].getExternalPoint(angle, p[\"gap\"]) : Utils.getPointByAngle(p[\"shape\"].getCenterPoint(), angle, p[\"gap\"]);\n  }\n\n  process3PointsXY(p1, p2, p3) {\n    if (p3[\"xy\"] == null) {\n      if (p3[\"shape\"] != null) {\n        this.process2PointsXY(p2, p3, true);\n      } else if (p3[\"angle\"] != null) {\n        this.process2PointsXY(p1, p3, true);\n      } else {\n        throw new Error(\"no way to calculate point.xy\");\n      }\n    }\n\n    if (p2[\"xy\"] == null) {\n      if (p2[\"angle\"] != null) {\n        p2[\"xy\"] = Utils.getPointByAngle(p1[\"xy\"], p2[\"angle\"], p2[\"gap\"]);\n        this.process2PointsXY(p2, p1, true);\n      } else if (p2[\"shape\"] != null) {\n        //as p2 is a shape, p2[\"xy\"] can vary by angle between 2 other shape, so lets use an angle in the middle of that 2\n        this.process2PointsXY(p2, p1, true);\n        let c2 = p2[\"shape\"].getCenterPoint();\n        let angle1 = Utils.getAngle(c2[0], c2[1], p1[\"xy\"][0], p1[\"xy\"][1]);\n        let angle3 = Utils.getAngle(c2[0], c2[1], p3[\"xy\"][0], p3[\"xy\"][1]);\n        let angle2 = (angle1 + angle3) / 2; //if angle1 - angle3 > 180deg => correct mid angle\n\n        if (Math.abs(angle1 - angle3) > Math.PI) angle2 -= Math.PI;\n        p2[\"xy\"] = this.getTargetXY(p2, angle2);\n      } else {\n        throw new Error(\"no way to calculate point.xy\");\n      }\n    }\n  } // getNeighbourPoint(point) {\n  //     let index;\n  //     for (index = 0; index < this.path.length; index++) if (this.path[index] === point) break\n  //     return index === 0 ? this.path[1] : this.path[index - 1];\n  // }\n  //\n  // /**\n  //  * @param shape1 shape 1\n  //  * @param shape2 shape 2\n  //  * @param gap the gap between line and target shapes. gap>=0\n  //  */\n  // between(shape1, shape2, gap = 0) {\n  //     let c1 = shape1.getCenterPoint();\n  //     let c2 = shape2.getCenterPoint();\n  //     c1 = shape1.getExternalPoint(Utils.getAngle(c1[0], c1[1], c2[0], c2[1]), gap);\n  //     c2 = shape2.getExternalPoint(Utils.getAngle(c2[0], c2[1], c1[0], c1[1]), gap);\n  //     this.setPosition(c1);\n  //     this.lineTo(c2);\n  //     return this;\n  // }\n  //\n  // /**\n  //  * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or shape\n  //  */\n  // lineTo(point) {\n  //     if (typeof point[0] === 'string') {\n  //         let i = point[0].length - 1;\n  //         let c = point[0][i];\n  //         let v = Number(point[0].substring(0, i));\n  //         if (c === 'R' || c === 'r') {\n  //             this.secondP = this.getTargetPoint(v, point[1]);\n  //         } else if (c === 'D' || c === 'd') {\n  //             this.secondP = this.getTargetPoint(Utils.deg2Rad(v), point[1]);\n  //         } else {\n  //             throw new Error('wrong input');\n  //         }\n  //     } else {\n  //         this.secondP = point;\n  //     }\n  //     return this;\n  // }\n  //\n  // getTargetPoint(r, d) {\n  //     let p = this.getPosition();\n  //     return [p[0] + Math.cos(r) * d, p[1] + Math.sin(r) * d];\n  // }\n\n\n  getCenterPoint() {\n    let p = this.getPosition();\n    return [(p[0] + this.secondP[0]) / 2, (p[1] + this.secondP[1]) / 2];\n  }\n  /**\n   * show arrows on the line\n   * @param direction 0 or 1\n   * @param places array of float values, each is 0 - 1;\n   * @return Shape\n   */\n\n\n  showArrow(direction, places) {\n    this.direction = direction;\n    this.places = places;\n    return this;\n  }\n\n  drawArrow(canvasCtx, length, angle, x, y) {\n    canvasCtx.beginPath();\n    let p1 = [x + length * Math.cos(angle - Utils._PI6), y + length * Math.sin(angle - Utils._PI6)];\n    let p2 = [x + length * Math.cos(angle + Utils._PI6), y + length * Math.sin(angle + Utils._PI6)];\n    canvasCtx.moveTo(x, y);\n    canvasCtx.lineTo(p1[0], p1[1]);\n    canvasCtx.lineTo(p2[0], p2[1]);\n    canvasCtx.closePath();\n    super.render(canvasCtx);\n  } // render(canvasCtx) {\n  //     let p1 = this.getPosition();\n  //     canvasCtx.beginPath();\n  //     canvasCtx.moveTo(p1[0], p1[1]);\n  //     canvasCtx.lineTo(this.secondP[0], this.secondP[1]);\n  //     canvasCtx.closePath();\n  //     super.render(canvasCtx);\n  //     if (this.direction !== undefined && this.places !== undefined) {\n  //         if (!this.places[0])\n  //             this.places = [this.places];\n  //         let angle = this.direction ? Utils.getAngle(this.secondP[0], this.secondP[1], p1[0], p1[1]) : Utils.getAngle(p1[0], p1[1], this.secondP[0], this.secondP[1]);\n  //         for (let i = 0; i < this.places.length; i++) {\n  //             let x = p1[0] + (this.secondP[0] - p1[0]) * this.places[i];\n  //             let y = p1[1] + (this.secondP[1] - p1[1]) * this.places[i];\n  //             this.drawArrow(canvasCtx, 10, angle, x, y);\n  //         }\n  //     }\n  // }\n\n\n}\nexport class HLine extends Line {\n  setLength(l) {\n    l > 0 ? this.lineTo(['0D', l]) : this.lineTo(['180D', -l]);\n    return this;\n  }\n\n}\nexport class VLine extends Line {\n  setLength(l) {\n    l > 0 ? this.lineTo(['90D', l]) : this.lineTo(['270D', -l]);\n    return this;\n  }\n\n}\nexport class Vector extends Line {\n  constructor() {\n    super();\n    this.setStrokeColor('black').setFillColor('black').setStrokeWidth(2).showArrow(1, 1);\n  }\n\n}\nexport class HVector extends Vector {\n  setLabel(label) {\n    if (typeof label === 'string') label = new Text().setPosition(this.getCenterPoint()).setLabel(label).setOffset([0, -6]).setFontStyle('');\n    return super.setLabel(label);\n  }\n\n  setLength(l) {\n    return l > 0 ? this.lineTo(['0D', l]) : this.lineTo(['180D', -l]);\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/simple/line.js"],"names":["Shape","Utils","Text","Line","constructor","path","setStrokeWidth","setPosition","position","addPoint","point","index","push","getPoint","i","length","ans","p","c","getTypeOf","v","Number","substring","normalizeRadian","deg2Rad","Error","render","canvasCtx","preparePoints","beginPath","moveTo","quadraticCurveTo","lineTo","process3PointsXY","process2PointsXY","p1","p2","ignoreP1XYModification","angle","c1","getCenterPoint","getPointByAngle","c2","getAngle","getTargetXY","Math","PI","getExternalPoint","p3","angle1","angle3","angle2","abs","getPosition","secondP","showArrow","direction","places","drawArrow","x","y","cos","_PI6","sin","closePath","HLine","setLength","l","VLine","Vector","setStrokeColor","setFillColor","HVector","setLabel","label","setOffset","setFontStyle"],"mappings":"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","sourcesContent":["import {Shape} from \"./shape\";\nimport {Utils} from \"../../../tools/utils\";\nimport {Text} from \"./text\";\n\nexport class Line extends Shape {\n    path = [];\n\n    constructor() {\n        super();\n        this.setStrokeWidth(1);\n    }\n\n    setPosition(position) {\n        return this.addPoint(position, 0);\n    }\n\n    addPoint(point, index = null) {\n        if (index == null) {\n            this.path.push(this.getPoint(point));\n        } else {\n            for (let i = this.path.length; i > index; i--)\n                this.path[i] = this.path[i - 1];\n            this.path[index] = this.getPoint(point);\n        }\n        return this;\n    }\n\n    /**\n     * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n     * you can have m & n before point location to make the line curvy:<br/>\n     * ex.<br/>\n     * [4, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [4, 5] in curvy shape<br/>\n     * [90d, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [90d, 5] in curvy shape<br/>\n     * [1r, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [1r, 5] in curvy shape<br/>\n     * [shape, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [shape, 5] in curvy shape<br/>\n     *\n     */\n    getPoint(point) {\n        let ans = {};\n        let p, c;\n        if (point[2] != null && point[3] != null) {\n            p = [point[2], point[3]];\n            c = [point[0], point[1]];\n        } else {\n            p = [point[0], point[1]];\n        }\n        switch (this.getTypeOf(p)) {\n            case \"number,number\"://[x,y]\n                ans[\"xy\"] = p;\n                break;\n            case \"string,number\"://[intR,length] or [intD,length]\n                let i = p[0].length - 1;\n                let c = p[0][i];\n                let v = Number(p[0].substring(0, i));\n                if (c === 'R' || c === 'r') {\n                    ans[\"angle\"] = Utils.normalizeRadian(v);\n                    ans[\"gap\"] = p[1];\n                } else if (c === 'D' || c === 'd') {\n                    ans[\"angle\"] = Utils.normalizeRadian(Utils.deg2Rad(v));\n                    ans[\"gap\"] = p[1];\n                } else {\n                    throw new Error('wrong input');\n                }\n                break;\n            case \"object,number\"://[shape,gap]\n                ans[\"shape\"] = p[0];\n                ans[\"gap\"] = p[1];\n                break;\n            default:\n                throw new Error('wrong input');\n        }\n        if (c != null) {\n            ans[\"curve\"] = this.getPoint(c);\n        }\n        return ans;\n    }\n\n    getTypeOf(point) {\n        return typeof point[0] + ',' + typeof point[1]\n    }\n\n    render(canvasCtx) {\n        this.preparePoints();\n        canvasCtx.beginPath();\n        let p = this.path[0];\n        canvasCtx.moveTo(p[\"xy\"][0], p[\"xy\"][1]);\n        for (let i = 1; i < this.path.length; i++) {\n            p = this.path[i];\n            if (p[\"curve\"] != null)\n                canvasCtx.quadraticCurveTo(p[\"curve\"][\"xy\"][0], p[\"curve\"][\"xy\"][1], p[\"xy\"][0], p[\"xy\"][1]);\n            else\n                canvasCtx.lineTo(p[\"xy\"][0], p[\"xy\"][1]);\n        }\n        // canvasCtx.closePath();\n        super.render(canvasCtx);\n    }\n\n    preparePoints() {\n        debugger\n        for (let i = 1; i < this.path.length; i++) {\n            if (this.path[i][\"curve\"] != null)\n                this.process3PointsXY(this.path[i - 1], this.path[\"curve\"], this.path[i])\n            else\n                this.process2PointsXY(this.path[i - 1], this.path[i])\n        }\n    }\n\n    process2PointsXY(p1, p2, ignoreP1XYModification = false) {\n        let angle;\n        if (p2[\"xy\"] == null) {\n            let c1 = p1[\"xy\"] != null ? p1[\"xy\"] : p1[\"shape\"].getCenterPoint();\n            if (p2[\"angle\"] != null) {\n                angle = p2[\"angle\"];\n                p2[\"xy\"] = Utils.getPointByAngle(c1, angle, p2[\"gap\"]);\n            } else if (p2[\"shape\"] != null) {\n                let c2 = p2[\"shape\"].getCenterPoint();\n                angle = Utils.getAngle(c2[0], c2[1], c1[0], c1[1]);\n                p2[\"xy\"] = this.getTargetXY(p2, angle);\n            } else {\n                throw new Error(\"no way to calculate point.xy\");\n            }\n        }\n\n        if (!ignoreP1XYModification && p1[\"xy\"] == null) {\n            p1[\"xy\"] = this.getTargetXY(p1, Math.PI - angle)\n        }\n    }\n\n    //p must be a shape\n    getTargetXY(p, angle) {\n        return (p[\"shape\"][\"getExternalPoint\"] != null) ?\n            p[\"shape\"].getExternalPoint(angle, p[\"gap\"]) :\n            Utils.getPointByAngle(p[\"shape\"].getCenterPoint(), angle, p[\"gap\"])\n    }\n\n    process3PointsXY(p1, p2, p3) {\n        if (p3[\"xy\"] == null) {\n            if (p3[\"shape\"] != null) {\n                this.process2PointsXY(p2, p3, true);\n            } else if (p3[\"angle\"] != null) {\n                this.process2PointsXY(p1, p3, true);\n            } else {\n                throw new Error(\"no way to calculate point.xy\");\n            }\n        }\n\n        if (p2[\"xy\"] == null) {\n            if (p2[\"angle\"] != null) {\n                p2[\"xy\"] = Utils.getPointByAngle(p1[\"xy\"], p2[\"angle\"], p2[\"gap\"]);\n                this.process2PointsXY(p2, p1, true);\n            } else if (p2[\"shape\"] != null) {\n                //as p2 is a shape, p2[\"xy\"] can vary by angle between 2 other shape, so lets use an angle in the middle of that 2\n                this.process2PointsXY(p2, p1, true);\n                let c2 = p2[\"shape\"].getCenterPoint();\n                let angle1 = Utils.getAngle(c2[0], c2[1], p1[\"xy\"][0], p1[\"xy\"][1]);\n                let angle3 = Utils.getAngle(c2[0], c2[1], p3[\"xy\"][0], p3[\"xy\"][1]);\n                let angle2 = (angle1 + angle3) / 2;\n\n                //if angle1 - angle3 > 180deg => correct mid angle\n                if (Math.abs(angle1 - angle3) > Math.PI)\n                    angle2 -= Math.PI;\n                p2[\"xy\"] = this.getTargetXY(p2, angle2);\n            } else {\n                throw new Error(\"no way to calculate point.xy\");\n            }\n        }\n    }\n\n    // getNeighbourPoint(point) {\n    //     let index;\n    //     for (index = 0; index < this.path.length; index++) if (this.path[index] === point) break\n    //     return index === 0 ? this.path[1] : this.path[index - 1];\n    // }\n    //\n    // /**\n    //  * @param shape1 shape 1\n    //  * @param shape2 shape 2\n    //  * @param gap the gap between line and target shapes. gap>=0\n    //  */\n    // between(shape1, shape2, gap = 0) {\n    //     let c1 = shape1.getCenterPoint();\n    //     let c2 = shape2.getCenterPoint();\n    //     c1 = shape1.getExternalPoint(Utils.getAngle(c1[0], c1[1], c2[0], c2[1]), gap);\n    //     c2 = shape2.getExternalPoint(Utils.getAngle(c2[0], c2[1], c1[0], c1[1]), gap);\n    //     this.setPosition(c1);\n    //     this.lineTo(c2);\n    //     return this;\n    // }\n    //\n    // /**\n    //  * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or shape\n    //  */\n    // lineTo(point) {\n    //     if (typeof point[0] === 'string') {\n    //         let i = point[0].length - 1;\n    //         let c = point[0][i];\n    //         let v = Number(point[0].substring(0, i));\n    //         if (c === 'R' || c === 'r') {\n    //             this.secondP = this.getTargetPoint(v, point[1]);\n    //         } else if (c === 'D' || c === 'd') {\n    //             this.secondP = this.getTargetPoint(Utils.deg2Rad(v), point[1]);\n    //         } else {\n    //             throw new Error('wrong input');\n    //         }\n    //     } else {\n    //         this.secondP = point;\n    //     }\n    //     return this;\n    // }\n    //\n    // getTargetPoint(r, d) {\n    //     let p = this.getPosition();\n    //     return [p[0] + Math.cos(r) * d, p[1] + Math.sin(r) * d];\n    // }\n\n    getCenterPoint() {\n        let p = this.getPosition();\n        return [(p[0] + this.secondP[0]) / 2, (p[1] + this.secondP[1]) / 2]\n    }\n\n    /**\n     * show arrows on the line\n     * @param direction 0 or 1\n     * @param places array of float values, each is 0 - 1;\n     * @return Shape\n     */\n    showArrow(direction, places) {\n        this.direction = direction;\n        this.places = places;\n        return this;\n    }\n\n    drawArrow(canvasCtx, length, angle, x, y) {\n        canvasCtx.beginPath();\n        let p1 = [x + length * Math.cos(angle - Utils._PI6), y + length * Math.sin(angle - Utils._PI6)];\n        let p2 = [x + length * Math.cos(angle + Utils._PI6), y + length * Math.sin(angle + Utils._PI6)];\n        canvasCtx.moveTo(x, y);\n        canvasCtx.lineTo(p1[0], p1[1]);\n        canvasCtx.lineTo(p2[0], p2[1]);\n        canvasCtx.closePath();\n        super.render(canvasCtx);\n    }\n\n    // render(canvasCtx) {\n    //     let p1 = this.getPosition();\n    //     canvasCtx.beginPath();\n    //     canvasCtx.moveTo(p1[0], p1[1]);\n    //     canvasCtx.lineTo(this.secondP[0], this.secondP[1]);\n    //     canvasCtx.closePath();\n    //     super.render(canvasCtx);\n    //     if (this.direction !== undefined && this.places !== undefined) {\n    //         if (!this.places[0])\n    //             this.places = [this.places];\n    //         let angle = this.direction ? Utils.getAngle(this.secondP[0], this.secondP[1], p1[0], p1[1]) : Utils.getAngle(p1[0], p1[1], this.secondP[0], this.secondP[1]);\n    //         for (let i = 0; i < this.places.length; i++) {\n    //             let x = p1[0] + (this.secondP[0] - p1[0]) * this.places[i];\n    //             let y = p1[1] + (this.secondP[1] - p1[1]) * this.places[i];\n    //             this.drawArrow(canvasCtx, 10, angle, x, y);\n    //         }\n    //     }\n    // }\n}\n\nexport class HLine\n    extends Line {\n    setLength(l) {\n        l > 0 ?\n            this.lineTo(['0D', l]) :\n            this.lineTo(['180D', -l])\n        return this;\n    }\n}\n\nexport class VLine extends Line {\n    setLength(l) {\n        l > 0 ?\n            this.lineTo(['90D', l]) :\n            this.lineTo(['270D', -l])\n        return this;\n    }\n}\n\nexport class Vector extends Line {\n    constructor() {\n        super();\n        this.setStrokeColor('black')\n            .setFillColor('black')\n            .setStrokeWidth(2)\n            .showArrow(1, 1);\n    }\n}\n\nexport class HVector extends Vector {\n    setLabel(label) {\n        if (typeof label === 'string')\n            label = new Text()\n                .setPosition(this.getCenterPoint())\n                .setLabel(label)\n                .setOffset([0, -6])\n                .setFontStyle('');\n        return super.setLabel(label);\n    }\n\n    setLength(l) {\n        return (l > 0) ?\n            this.lineTo(['0D', l]) :\n            this.lineTo(['180D', -l])\n    }\n}"]},"metadata":{},"sourceType":"module"}