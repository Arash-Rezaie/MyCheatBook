{"ast":null,"code":"import { Shape } from \"./shape\";\nimport { Utils } from \"../../../tools/utils\";\nimport { Text } from \"./text\";\nexport class Line extends Shape {\n  constructor() {\n    super();\n    this.path = [];\n    this.setStrokeWidth(1);\n  }\n\n  setPosition(position) {\n    this.path[0] = position;\n    return this;\n  }\n\n  getPosition() {\n    return this.getPoint(this.path[0]);\n  }\n\n  getTypeOf(point) {\n    return [typeof point[0], typeof point[1]];\n  }\n  /**\n   * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap]\n   */\n\n\n  getPoint(point) {\n    switch (this.getTypeOf(point)) {\n      case [\"number\", \"number\"]:\n        //[x,y]\n        return [point];\n\n      case [\"string\", \"number\"]:\n        //[intR,length] or [intD,length]\n        let i = point[0].length - 1;\n        let c = point[0][i];\n        let v = Number(point[0].substring(0, i));\n\n        if (c === 'R' || c === 'r') {\n          return this.getTargetPoint(v, point[1]);\n        } else if (c === 'D' || c === 'd') {\n          return this.getTargetPoint(Utils.deg2Rad(v), point[1]);\n        } else {\n          throw new Error('wrong input');\n        }\n\n      case [\"object\", \"number\"]:\n        //[shape,gap]\n        let c1 = point[0].getCenterPoint();\n        let c2 = this.getNeighbourPoint(point);\n        c1 = point[0].getExternalPoint(Utils.getAngle(c1[0], c1[1], c2[0], c2[1]), point[1]);\n        c2 = shape2.getExternalPoint(Utils.getAngle(c2[0], c2[1], c1[0], c1[1]), point[1]);\n        this.setPosition(c1);\n        this.lineTo(c2);\n        break;\n\n      default:\n        throw new Error('wrong input');\n    }\n  }\n\n  getNeighbourPoint(point) {\n    let index;\n\n    for (index = 0; index < this.path.length; index++) if (this.path[index] === point) break;\n\n    return index === 0 ? this.path[1] : this.path[index - 1];\n  }\n  /**\n   * @param shape1 shape 1\n   * @param shape2 shape 2\n   * @param gap the gap between line and target shapes. gap>=0\n   */\n\n\n  between(shape1, shape2, gap = 0) {\n    let c1 = shape1.getCenterPoint();\n    let c2 = shape2.getCenterPoint();\n    c1 = shape1.getExternalPoint(Utils.getAngle(c1[0], c1[1], c2[0], c2[1]), gap);\n    c2 = shape2.getExternalPoint(Utils.getAngle(c2[0], c2[1], c1[0], c1[1]), gap);\n    this.setPosition(c1);\n    this.lineTo(c2);\n    return this;\n  }\n  /**\n   * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or shape\n   */\n\n\n  lineTo(point) {\n    if (typeof point[0] === 'string') {\n      let i = point[0].length - 1;\n      let c = point[0][i];\n      let v = Number(point[0].substring(0, i));\n\n      if (c === 'R' || c === 'r') {\n        this.secondP = this.getTargetPoint(v, point[1]);\n      } else if (c === 'D' || c === 'd') {\n        this.secondP = this.getTargetPoint(Utils.deg2Rad(v), point[1]);\n      } else {\n        throw new Error('wrong input');\n      }\n    } else {\n      this.secondP = point;\n    }\n\n    return this;\n  }\n\n  getTargetPoint(r, d) {\n    let p = this.getPosition();\n    return [p[0] + Math.cos(r) * d, p[1] + Math.sin(r) * d];\n  }\n\n  getCenterPoint() {\n    let p = this.getPosition();\n    return [(p[0] + this.secondP[0]) / 2, (p[1] + this.secondP[1]) / 2];\n  }\n  /**\n   * show arrows on the line\n   * @param direction 0 or 1\n   * @param places array of float values, each is 0 - 1;\n   * @return Shape\n   */\n\n\n  showArrow(direction, places) {\n    this.direction = direction;\n    this.places = places;\n    return this;\n  }\n\n  drawArrow(canvasCtx, length, angle, x, y) {\n    canvasCtx.beginPath();\n    let p1 = [x + length * Math.cos(angle - Utils._PI6), y + length * Math.sin(angle - Utils._PI6)];\n    let p2 = [x + length * Math.cos(angle + Utils._PI6), y + length * Math.sin(angle + Utils._PI6)];\n    canvasCtx.moveTo(x, y);\n    canvasCtx.lineTo(p1[0], p1[1]);\n    canvasCtx.lineTo(p2[0], p2[1]);\n    canvasCtx.closePath();\n    super.render(canvasCtx);\n  }\n\n  render(canvasCtx) {\n    let p1 = this.getPosition();\n    canvasCtx.beginPath();\n    canvasCtx.moveTo(p1[0], p1[1]);\n    canvasCtx.lineTo(this.secondP[0], this.secondP[1]);\n    canvasCtx.closePath();\n    super.render(canvasCtx);\n\n    if (this.direction !== undefined && this.places !== undefined) {\n      if (!this.places[0]) this.places = [this.places];\n      let angle = this.direction ? Utils.getAngle(this.secondP[0], this.secondP[1], p1[0], p1[1]) : Utils.getAngle(p1[0], p1[1], this.secondP[0], this.secondP[1]);\n\n      for (let i = 0; i < this.places.length; i++) {\n        let x = p1[0] + (this.secondP[0] - p1[0]) * this.places[i];\n        let y = p1[1] + (this.secondP[1] - p1[1]) * this.places[i];\n        this.drawArrow(canvasCtx, 10, angle, x, y);\n      }\n    }\n  }\n\n}\nexport class HLine extends Line {\n  setLength(l) {\n    l > 0 ? this.lineTo(['0D', l]) : this.lineTo(['180D', -l]);\n    return this;\n  }\n\n}\nexport class VLine extends Line {\n  setLength(l) {\n    l > 0 ? this.lineTo(['90D', l]) : this.lineTo(['270D', -l]);\n    return this;\n  }\n\n}\nexport class Vector extends Line {\n  constructor() {\n    super();\n    this.setStrokeColor('black').setFillColor('black').setStrokeWidth(2).showArrow(1, 1);\n  }\n\n}\nexport class HVector extends Vector {\n  setLabel(label) {\n    if (typeof label === 'string') label = new Text().setPosition(this.getCenterPoint()).setLabel(label).setOffset([0, -6]).setFontStyle('');\n    return super.setLabel(label);\n  }\n\n  setLength(l) {\n    return l > 0 ? this.lineTo(['0D', l]) : this.lineTo(['180D', -l]);\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/simple/line.js"],"names":["Shape","Utils","Text","Line","constructor","path","setStrokeWidth","setPosition","position","getPosition","getPoint","getTypeOf","point","i","length","c","v","Number","substring","getTargetPoint","deg2Rad","Error","c1","getCenterPoint","c2","getNeighbourPoint","getExternalPoint","getAngle","shape2","lineTo","index","between","shape1","gap","secondP","r","d","p","Math","cos","sin","showArrow","direction","places","drawArrow","canvasCtx","angle","x","y","beginPath","p1","_PI6","p2","moveTo","closePath","render","undefined","HLine","setLength","l","VLine","Vector","setStrokeColor","setFillColor","HVector","setLabel","label","setOffset","setFontStyle"],"mappings":"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","sourcesContent":["import {Shape} from \"./shape\";\nimport {Utils} from \"../../../tools/utils\";\nimport {Text} from \"./text\";\n\nexport class Line extends Shape {\n    path = [];\n\n    constructor() {\n        super();\n        this.setStrokeWidth(1);\n    }\n\n    setPosition(position) {\n        this.path[0] = position;\n        return this;\n    }\n\n    getPosition() {\n        return this.getPoint(this.path[0]);\n    }\n\n    getTypeOf(point) {\n        return [typeof point[0], typeof point[1]];\n    }\n\n    /**\n     * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap]\n     */\n    getPoint(point) {\n        switch (this.getTypeOf(point)) {\n            case [\"number\", \"number\"]://[x,y]\n                return [point];\n            case [\"string\", \"number\"]://[intR,length] or [intD,length]\n                let i = point[0].length - 1;\n                let c = point[0][i];\n                let v = Number(point[0].substring(0, i));\n                if (c === 'R' || c === 'r') {\n                    return this.getTargetPoint(v, point[1]);\n                } else if (c === 'D' || c === 'd') {\n                    return this.getTargetPoint(Utils.deg2Rad(v), point[1]);\n                } else {\n                    throw new Error('wrong input');\n                }\n            case [\"object\", \"number\"]://[shape,gap]\n                let c1 = point[0].getCenterPoint();\n                let c2 = this.getNeighbourPoint(point);\n                c1 = point[0].getExternalPoint(Utils.getAngle(c1[0], c1[1], c2[0], c2[1]), point[1]);\n                c2 = shape2.getExternalPoint(Utils.getAngle(c2[0], c2[1], c1[0], c1[1]), point[1]);\n                this.setPosition(c1);\n                this.lineTo(c2);\n                break;\n            default:\n                throw new Error('wrong input');\n        }\n    }\n\n    getNeighbourPoint(point) {\n        let index;\n        for (index = 0; index < this.path.length; index++) if (this.path[index] === point) break\n        return index === 0 ? this.path[1] : this.path[index - 1];\n    }\n\n    /**\n     * @param shape1 shape 1\n     * @param shape2 shape 2\n     * @param gap the gap between line and target shapes. gap>=0\n     */\n    between(shape1, shape2, gap = 0) {\n        let c1 = shape1.getCenterPoint();\n        let c2 = shape2.getCenterPoint();\n        c1 = shape1.getExternalPoint(Utils.getAngle(c1[0], c1[1], c2[0], c2[1]), gap);\n        c2 = shape2.getExternalPoint(Utils.getAngle(c2[0], c2[1], c1[0], c1[1]), gap);\n        this.setPosition(c1);\n        this.lineTo(c2);\n        return this;\n    }\n\n    /**\n     * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or shape\n     */\n    lineTo(point) {\n        if (typeof point[0] === 'string') {\n            let i = point[0].length - 1;\n            let c = point[0][i];\n            let v = Number(point[0].substring(0, i));\n            if (c === 'R' || c === 'r') {\n                this.secondP = this.getTargetPoint(v, point[1]);\n            } else if (c === 'D' || c === 'd') {\n                this.secondP = this.getTargetPoint(Utils.deg2Rad(v), point[1]);\n            } else {\n                throw new Error('wrong input');\n            }\n        } else {\n            this.secondP = point;\n        }\n        return this;\n    }\n\n    getTargetPoint(r, d) {\n        let p = this.getPosition();\n        return [p[0] + Math.cos(r) * d, p[1] + Math.sin(r) * d];\n    }\n\n    getCenterPoint() {\n        let p = this.getPosition();\n        return [(p[0] + this.secondP[0]) / 2, (p[1] + this.secondP[1]) / 2]\n    }\n\n    /**\n     * show arrows on the line\n     * @param direction 0 or 1\n     * @param places array of float values, each is 0 - 1;\n     * @return Shape\n     */\n    showArrow(direction, places) {\n        this.direction = direction;\n        this.places = places;\n        return this;\n    }\n\n    drawArrow(canvasCtx, length, angle, x, y) {\n        canvasCtx.beginPath();\n        let p1 = [x + length * Math.cos(angle - Utils._PI6), y + length * Math.sin(angle - Utils._PI6)];\n        let p2 = [x + length * Math.cos(angle + Utils._PI6), y + length * Math.sin(angle + Utils._PI6)];\n        canvasCtx.moveTo(x, y);\n        canvasCtx.lineTo(p1[0], p1[1]);\n        canvasCtx.lineTo(p2[0], p2[1]);\n        canvasCtx.closePath();\n        super.render(canvasCtx);\n    }\n\n    render(canvasCtx) {\n        let p1 = this.getPosition();\n        canvasCtx.beginPath();\n        canvasCtx.moveTo(p1[0], p1[1]);\n        canvasCtx.lineTo(this.secondP[0], this.secondP[1]);\n        canvasCtx.closePath();\n        super.render(canvasCtx);\n        if (this.direction !== undefined && this.places !== undefined) {\n            if (!this.places[0])\n                this.places = [this.places];\n            let angle = this.direction ? Utils.getAngle(this.secondP[0], this.secondP[1], p1[0], p1[1]) : Utils.getAngle(p1[0], p1[1], this.secondP[0], this.secondP[1]);\n            for (let i = 0; i < this.places.length; i++) {\n                let x = p1[0] + (this.secondP[0] - p1[0]) * this.places[i];\n                let y = p1[1] + (this.secondP[1] - p1[1]) * this.places[i];\n                this.drawArrow(canvasCtx, 10, angle, x, y);\n            }\n        }\n    }\n}\n\nexport class HLine\n    extends Line {\n    setLength(l) {\n        l > 0 ?\n            this.lineTo(['0D', l]) :\n            this.lineTo(['180D', -l])\n        return this;\n    }\n}\n\nexport class VLine extends Line {\n    setLength(l) {\n        l > 0 ?\n            this.lineTo(['90D', l]) :\n            this.lineTo(['270D', -l])\n        return this;\n    }\n}\n\nexport class Vector extends Line {\n    constructor() {\n        super();\n        this.setStrokeColor('black')\n            .setFillColor('black')\n            .setStrokeWidth(2)\n            .showArrow(1, 1);\n    }\n}\n\nexport class HVector extends Vector {\n    setLabel(label) {\n        if (typeof label === 'string')\n            label = new Text()\n                .setPosition(this.getCenterPoint())\n                .setLabel(label)\n                .setOffset([0, -6])\n                .setFontStyle('');\n        return super.setLabel(label);\n    }\n\n    setLength(l) {\n        return (l > 0) ?\n            this.lineTo(['0D', l]) :\n            this.lineTo(['180D', -l])\n    }\n}"]},"metadata":{},"sourceType":"module"}