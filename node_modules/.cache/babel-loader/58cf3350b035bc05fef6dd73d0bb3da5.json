{"ast":null,"code":"import { Path } from \"../simple/path\";\nimport { Utils } from \"../../../tools/utils\";\nexport class WrapperPath extends Path {\n  constructor(handler) {\n    super();\n    this.handler = handler;\n  }\n\n  getLabel() {\n    let lbl = super.getLabel();\n    return lbl.label ? this.handler.generateShape(lbl).alignTo(this) : lbl;\n  }\n  /**\n   * offset can come after each point, then offset affects the that point<br/>\n   * quadratic can come before a line, then quadratic affects the proceeding line\n   * x,y: [x,y] or [intR,length] for radian, [intD,length] for degree or [shape,gap].<br/>\n   * ox,oy: [num,num]<br/>\n   *\n   * @param path\n   *      'm x y':moveTo([x,y])<br/>\n   *      'l x y':lineTo([x,y])<br/>\n   *      'q x y':quadraticTo([x,y])<br/>\n   *      'o ox oy':offset([ox,oy])<br/>\n   *\n   * @return {WrapperPath}\n   */\n\n\n  setPath(path) {\n    debugger;\n    let arr = path.split(/ +/);\n    this.path = [];\n\n    for (let i = 0; i < arr.length; i++) {\n      switch (arr[i]) {\n        case 'm':\n          this.path.push({\n            m: 'moveTo',\n            args: [[this.getTargetShape(arr[i + 1]), arr[i + 2]]]\n          });\n          break;\n\n        case 'o':\n          Utils.last(Utils.last(this.path).args).push(arr[i + 1], arr[i + 2]);\n          break;\n\n        case 'q':\n          this.path.push({\n            m: 'quadraticTo',\n            args: [[this.getTargetShape(arr[i + 1]), arr[i + 2]]]\n          });\n          break;\n\n        case 'l':\n          Utils.last(this.path).m === 'quadraticTo' ? Utils.last(this.path).args.push([this.getTargetShape(arr[i + 1]), arr[i + 2]]) : this.path.push({\n            m: 'lineTo',\n            args: [[this.getTargetShape(arr[i + 1]), arr[i + 2]]]\n          });\n          break;\n\n        default:\n          throw new Error('Wrong input');\n      }\n\n      i += 2;\n    }\n\n    return this;\n  }\n\n  getTargetShape(value) {\n    return typeof value === 'string' && !value.match('\\\\d+[dDrR]') ? this.handler.getTargetShape(value) : value;\n  }\n\n  moveTo(...points) {\n    return super.moveTo(points[0]);\n  }\n\n  lineTo(...points) {\n    return super.lineTo(points[0]);\n  }\n\n  quadraticTo(...points) {\n    return super.quadraticTo(points[0], points[1]);\n  }\n\n  render(canvasCtx) {\n    this.path.forEach(v => this[v.m](v.args));\n    super.render(canvasCtx);\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/wrappered/wrapper-path.js"],"names":["Path","Utils","WrapperPath","constructor","handler","getLabel","lbl","label","generateShape","alignTo","setPath","path","arr","split","i","length","push","m","args","getTargetShape","last","Error","value","match","moveTo","points","lineTo","quadraticTo","render","canvasCtx","forEach","v"],"mappings":"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","sourcesContent":["import {Path} from \"../simple/path\";\nimport {Utils} from \"../../../tools/utils\";\n\nexport class WrapperPath extends Path {\n    constructor(handler) {\n        super();\n        this.handler = handler;\n    }\n\n    getLabel() {\n        let lbl = super.getLabel();\n        return (lbl.label) ? this.handler.generateShape(lbl).alignTo(this) : lbl;\n    }\n\n    /**\n     * offset can come after each point, then offset affects the that point<br/>\n     * quadratic can come before a line, then quadratic affects the proceeding line\n     * x,y: [x,y] or [intR,length] for radian, [intD,length] for degree or [shape,gap].<br/>\n     * ox,oy: [num,num]<br/>\n     *\n     * @param path\n     *      'm x y':moveTo([x,y])<br/>\n     *      'l x y':lineTo([x,y])<br/>\n     *      'q x y':quadraticTo([x,y])<br/>\n     *      'o ox oy':offset([ox,oy])<br/>\n     *\n     * @return {WrapperPath}\n     */\n    setPath(path) {\n        debugger\n        let arr = path.split(/ +/);\n        this.path = [];\n        for (let i = 0; i < arr.length; i++) {\n            switch (arr[i]) {\n                case 'm':\n                    this.path.push({m: 'moveTo', args: [[this.getTargetShape(arr[i + 1]), arr[i + 2]]]});\n                    break;\n                case 'o':\n                    Utils.last(Utils.last(this.path).args).push(arr[i + 1], arr[i + 2]);\n                    break;\n                case 'q':\n                    this.path.push({m: 'quadraticTo', args: [[this.getTargetShape(arr[i + 1]), arr[i + 2]]]})\n                    break;\n                case 'l':\n                    Utils.last(this.path).m === 'quadraticTo' ?\n                        Utils.last(this.path).args.push([this.getTargetShape(arr[i + 1]), arr[i + 2]]) :\n                        this.path.push({m: 'lineTo', args: [[this.getTargetShape(arr[i + 1]), arr[i + 2]]]})\n                    break;\n                default:\n                    throw new Error('Wrong input')\n            }\n            i += 2;\n        }\n        return this;\n    }\n\n    getTargetShape(value) {\n        return (typeof value === 'string' && !value.match('\\\\d+[dDrR]')) ? this.handler.getTargetShape(value) : value;\n    }\n\n    moveTo(...points) {\n        return super.moveTo(points[0]);\n    }\n\n    lineTo(...points) {\n        return super.lineTo(points[0]);\n    }\n\n    quadraticTo(...points) {\n        return super.quadraticTo(points[0], points[1]);\n    }\n\n    render(canvasCtx) {\n        this.path.forEach(v => this[v.m](v.args));\n        super.render(canvasCtx);\n    }\n}"]},"metadata":{},"sourceType":"module"}