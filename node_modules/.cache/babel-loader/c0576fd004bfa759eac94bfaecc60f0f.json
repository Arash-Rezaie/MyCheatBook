{"ast":null,"code":"import { WrapperPath } from \"./wrapper-path\";\nimport { Utils } from \"../../../tools/utils\";\nexport class WrapperTypeRel extends WrapperPath {\n  constructor(handler) {\n    super(handler);\n  }\n\n  setPath(path) {\n    throw new Error('you must use between');\n  }\n  /**\n   *\n   * @param shapeObject1 [shapeId, offsetX,offsetY]\n   * @param shapeObject2 [shapeId, offsetX,offsetY]\n   * @param breaker [distance from shape1,'_' or '|', fixation] : [30,'|']\n   */\n\n\n  between(shapeObject1, shapeObject2, breaker) {\n    let s = 'm ' + this.getShapeString(shapeObject1) + ' ' + this.getLineString(shapeObject1, shapeObject2, breaker) + ' l ' + this.getShapeString(shapeObject2);\n    super.setPath(s);\n  }\n\n  getTargetPoint(shape) {\n    let p = this.getTargetShape(shape[0]).getCenterPoint();\n\n    if (shape[1] != null && shape[2] != null) {\n      p[0] += shape[1];\n      p[1] += shape[2];\n    }\n\n    return p;\n  }\n\n  getShapeString(shapeInput) {\n    let s = shapeInput[0] + ' 2';\n\n    if (shapeInput[1] != null && shapeInput[2] != null) {\n      s += ` o ${shapeInput[1]} ${shapeInput[2]}`;\n    }\n\n    return s;\n  }\n\n  getLineString(shapeObject1, shapeObject2, breaker) {\n    if (breaker[2]) debugger;\n    let p1 = this.getTargetPoint(shapeObject1);\n    let p2 = this.getTargetPoint(shapeObject2);\n    let angle = Utils.normalizeDegree(Utils.rad2Deg(Utils.getAngleByPoint(p1, p2)));\n    let s;\n\n    if (breaker[1] === '_') {\n      let [l, d] = this.processLen(p2[0] - p1[0], breaker, 0);\n      s = angle < 180 ? `l 90d ${breaker[0]} l ${d}d ${l}` : `l 270d ${breaker[0]} l ${d}d ${l}`;\n    } else {\n      let [l, d] = this.processLen(p2[1] - p1[1], breaker, 90);\n      s = angle < 90 && angle > 270 ? `l 0d ${breaker[0]} l ${d}d ${l}` : `l 180d ${breaker[0]} l ${d}d ${l}`;\n    }\n\n    return s;\n  }\n\n  processLen(l, breaker, d) {\n    if (l < 0) {\n      l = -l;\n      d += 180;\n    }\n\n    if (breaker[2] != null) l += breaker[2];\n    return [l, d];\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/wrappered/wrapper-type-rel.js"],"names":["WrapperPath","Utils","WrapperTypeRel","constructor","handler","setPath","path","Error","between","shapeObject1","shapeObject2","breaker","s","getShapeString","getLineString","getTargetPoint","shape","p","getTargetShape","getCenterPoint","shapeInput","p1","p2","angle","normalizeDegree","rad2Deg","getAngleByPoint","l","d","processLen"],"mappings":"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","sourcesContent":["import {WrapperPath} from \"./wrapper-path\";\nimport {Utils} from \"../../../tools/utils\";\n\nexport class WrapperTypeRel extends WrapperPath {\n    constructor(handler) {\n        super(handler);\n    }\n\n    setPath(path) {\n        throw new Error('you must use between')\n    }\n\n    /**\n     *\n     * @param shapeObject1 [shapeId, offsetX,offsetY]\n     * @param shapeObject2 [shapeId, offsetX,offsetY]\n     * @param breaker [distance from shape1,'_' or '|', fixation] : [30,'|']\n     */\n    between(shapeObject1, shapeObject2, breaker) {\n        let s = 'm ' + this.getShapeString(shapeObject1) + ' ' +\n            this.getLineString(shapeObject1, shapeObject2, breaker) + ' l ' +\n            this.getShapeString(shapeObject2);\n        super.setPath(s);\n    }\n\n    getTargetPoint(shape) {\n        let p = this.getTargetShape(shape[0]).getCenterPoint();\n        if (shape[1] != null && shape[2] != null) {\n            p[0] += shape[1];\n            p[1] += shape[2];\n        }\n        return p;\n    }\n\n    getShapeString(shapeInput,) {\n        let s = shapeInput[0] + ' 2';\n        if (shapeInput[1] != null && shapeInput[2] != null) {\n            s += ` o ${shapeInput[1]} ${shapeInput[2]}`;\n        }\n        return s;\n    }\n\n    getLineString(shapeObject1, shapeObject2, breaker) {\n        if(breaker[2])\n            debugger\n        let p1 = this.getTargetPoint(shapeObject1);\n        let p2 = this.getTargetPoint(shapeObject2);\n        let angle = Utils.normalizeDegree(Utils.rad2Deg(Utils.getAngleByPoint(p1, p2)));\n        let s;\n        if (breaker[1] === '_') {\n            let [l, d] = this.processLen(p2[0] - p1[0], breaker, 0);\n            s = angle < 180 ? `l 90d ${breaker[0]} l ${d}d ${l}` : `l 270d ${breaker[0]} l ${d}d ${l}`;\n        } else {\n            let [l, d] = this.processLen(p2[1] - p1[1], breaker, 90);\n            s = (angle < 90 && angle > 270) ? `l 0d ${breaker[0]} l ${d}d ${l}` : `l 180d ${breaker[0]} l ${d}d ${l}`;\n        }\n        return s;\n    }\n\n    processLen(l, breaker, d) {\n        if (l < 0) {\n            l = -l;\n            d += 180;\n        }\n        if (breaker[2] != null)\n            l += breaker[2];\n        return [l, d];\n    }\n}"]},"metadata":{},"sourceType":"module"}