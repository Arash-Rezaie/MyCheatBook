{"ast":null,"code":"import { Text } from \"./simple/text\";\nimport { Circle } from \"./simple/circle\";\nimport { Rectangle } from \"./simple/rectangle\";\nimport { DrawBox } from \"./draw-box\";\nimport { HLine, Line } from \"./simple/line\";\nimport { ExtendedHVector, ExtendedLine, ExtendedVector, ExtendedVLine } from \"./extended/extended-line\";\nimport { Node } from \"./extended/node\";\nimport { Caption } from \"./extended/caption\";\nexport class DrawBoxHandler {\n  constructor() {\n    this.METHOD_POINTERS = {\n      text: () => new Text(),\n      circle: () => new Circle(),\n      line: () => new ExtendedLine(this),\n      rect: () => new Rectangle(),\n      node: () => new Node(this),\n      cap: () => new Caption(this),\n      hline: () => new ExtendedLine(this),\n      vline: () => new ExtendedVLine(this),\n      vect: () => new ExtendedVector(this),\n      hvect: () => new ExtendedHVector(this),\n      label: (d, o) => {\n        typeof d === 'string' ? o.setLabel(d) : o.setLabel();\n      },\n      color: (d, o) => o.setColor(d),\n      fillColor: (d, o) => o.setFillColor(d),\n      strokeColor: (d, o) => o.setStrokeColor(d),\n      strokeWidth: (d, o) => o.setStrokeWidth(d),\n      strokeStyle: (d, o) => o.setStrokeStyle(d),\n      radius: (d, o) => o.setRadius(d),\n      fontSize: (d, o) => o.setFontSize(d),\n      fontStyle: (d, o) => o.setFontStyle(d),\n      lineto: (d, o) => o.lineto(d),\n      arrow: (d, o) => o.showArrow(d[0], d[1]),\n      len: (d, o) => o.setLength(d),\n      between: (d, o) => o.between(d),\n      width: (d, o) => o.setWidth(d),\n      height: (d, o) => o.setHeight(d),\n      conn: (d, o) => o.connectTo(d),\n      captions: (d, o) => o.setCaptions(d)\n    };\n    this.drawBox = new DrawBox();\n    this.container = {};\n  }\n  /**\n   * @param itemConf it is an object with fields:<br/>\n   * {\n   *    shape: ['text', 'circle', 'line', 'rect', 'node', 'cap', 'hline', 'vline', 'vect', 'hvect']<br/>\n   *\n   *    --- generic ------<br/>\n   *    id: string<br/>\n   *    pos: [x, y]<br/>\n   *    align: shape<br/>\n   *    offset: [dx, dy]<br/>\n   *    label: [string, Text-object<br/>\n   *    color: ['green', 'blue', 'red', 'yellow', 'purple', 'brown', 'orange', 'pink'], (set fill & stroke together)<br/>\n   *    fillColor: color<br/>\n   *    strokeColor: color<br/>\n   *    strokeWidth: int<br/>\n   *    strokeStyle: [int, int], (make stroke dashed)<br/>\n   *\n   *    --- circle ------<br/>\n   *    radius: int<br/>\n   *\n   *    --- Text ------<br/>\n   *    fontSize: value, (ex. '20px' or '12em'<br/>\n   *    fontStyle: ['bold', 'italic', 'bold italic'<br/>\n   *\n   *    --- all line types ------<br/>\n   *    lineto: [x,y] or [intR, length] or [intD, length]<br/>\n   *    arrow: [dir([true, false]), places([0 - 1])]<br/>\n   *    between: [id1, id2, gap]<br/>\n   *\n   *    --- hline & vline & hvect ------<br/>\n   *    len: int<br/>\n   *\n   *    --- rectangle ------<br/>\n   *    width: int<br/>\n   *    height: int<br/>\n   *\n   *    --- node & cap ------<br/>\n   *    conn: ref-id. (connect to the aligned shape)<br/>\n   *    captions: [{t:string, c: 'color string', w:width, offset:[x=0,y=0]}]<br/>\n   * }\n   */\n\n\n  addShape(itemConf) {\n    this.drawBox.addShape(this.generateShape(itemConf));\n    return this;\n  }\n\n  generateShape(itemConf) {\n    debugger;\n    let o = this.METHOD_POINTERS[itemConf.shape](itemConf);\n    this.initShape(itemConf, o);\n    let t;\n\n    for (t in itemConf) {\n      if (t !== 'shape' && t !== 'id' && t !== 'pos' && t !== 'align' && t !== 'offset') {\n        this.METHOD_POINTERS[t](itemConf[t], o);\n      }\n    }\n\n    return o;\n  }\n\n  initShape(conf, o) {\n    if (conf.id) this.container[conf.id] = o;\n    if (conf.pos) o.setPosition(conf.pos);\n    if (conf.align) o.alignTo(this.container[conf.align]);\n\n    if (conf.offset) {\n      o.setOffset(conf.offset);\n    }\n\n    return o;\n  }\n\n  getTargetShape(id) {\n    return this.container[id];\n  } // generateNode() {\n  //     //crate new circle\n  //     let o = new Circle()\n  //         .setRadius(20)\n  //         .setStrokeWidth(3)\n  //         .setStrokeColor('black')\n  //         .setFillColor('yellow');\n  //\n  //     //redirect setLabel to a new method\n  //     this.applyCustomLabel(o, lbl =>\n  //         new Text()\n  //             .setPosition(o.getCenterPoint())\n  //             .setLabel(lbl)\n  //             .setFontSize('20px')\n  //             .setOffset([0, 6]));\n  //     o['connectTo'] = refId => {\n  //         this.drawBox.addShape(this.generateVector()\n  //             .superBetween(o, this.container[refId], 5));\n  //         return o;\n  //     };\n  //     o['setCaptions'] = caps => {\n  //         if (caps[0] === undefined)\n  //             caps = [caps];\n  //         caps.forEach((v, i) => {\n  //             this.drawBox.addShape(\n  //                 this.generateCaption()\n  //                     .alignTo(o)\n  //                     .setOffset(v.offset ? v.offset : [28, (caps.length * -11.5 + (i * 25))])\n  //                     .setWidth(v.w)\n  //                     .setHeight(20)\n  //                     .setLabel(v.t)\n  //                     .setColor(v.c)\n  //                     .setStrokeWidth(2)\n  //             )\n  //         })\n  //         return o;\n  //     };\n  //     return o;\n  // }\n  //\n  // generateCaption() {\n  //     let o = new Rectangle()\n  //     this.applyCustomLabel(o, lbl =>\n  //         new Text()\n  //             .setPosition(o.getCenterPoint())\n  //             .setLabel(lbl)\n  //             .setOffset([0, 5])\n  //             .setFontStyle('bold'));\n  //     o['connectTo'] = refId => {\n  //         this.drawBox.addShape(new Line()\n  //             .between(o, this.container[refId], 5)\n  //             .setStrokeColor('red')\n  //             .setFillColor('red')\n  //             .setStrokeWidth(1));\n  //         return o;\n  //     };\n  //     return o;\n  // }\n  //\n  // generateLine(labelProducer = null) {\n  //     let o = new Line();\n  //     o['superBetween'] = o.between;\n  //     o[\"between\"] = data => o.superBetween(this.container[data[0]], this.container[data[1]], data[2]);\n  //     this.applyCustomLabel(o, labelProducer);\n  //     return o;\n  // }\n  //\n  // prepareLine(o){\n  //     o['superBetween'] = o.between;\n  //     o[\"between\"] = data => o.superBetween(this.container[data[0]], this.container[data[1]], data[2]);\n  //     this.applyCustomLabel(o);\n  //     return o;\n  // }\n  //\n  //\n  // applyCustomLabel(shape, textModifier = null) {\n  //     shape['setText'] = shape.setLabel;\n  //     shape['setLabel'] = lbl => {\n  //         return (typeof lbl === 'string') ?\n  //             shape.setText(textModifier ? textModifier(lbl) : lbl) :\n  //             shape.setText(this.generateShape(lbl).alignTo(shape))\n  //     };\n  // }\n\n\n  render(canvas) {\n    this.drawBox.render(canvas);\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/draw-box-handler.js"],"names":["Text","Circle","Rectangle","DrawBox","HLine","Line","ExtendedHVector","ExtendedLine","ExtendedVector","ExtendedVLine","Node","Caption","DrawBoxHandler","constructor","METHOD_POINTERS","text","circle","line","rect","node","cap","hline","vline","vect","hvect","label","d","o","setLabel","color","setColor","fillColor","setFillColor","strokeColor","setStrokeColor","strokeWidth","setStrokeWidth","strokeStyle","setStrokeStyle","radius","setRadius","fontSize","setFontSize","fontStyle","setFontStyle","lineto","arrow","showArrow","len","setLength","between","width","setWidth","height","setHeight","conn","connectTo","captions","setCaptions","drawBox","container","addShape","itemConf","generateShape","shape","initShape","t","conf","id","pos","setPosition","align","alignTo","offset","setOffset","getTargetShape","render","canvas"],"mappings":"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,IAAI,CAACM,MAAT,EAAiB;AACb9C,MAAAA,CAAC,CAAC+C,SAAF,CAAYP,IAAI,CAACM,MAAjB;AACH;;AACD,WAAO9C,CAAP;AACH;;AAEDgD,EAAAA,cAAc,CAACP,EAAD,EAAI;AACd,WAAO,KAAKR,SAAL,CAAeQ,EAAf,CAAP;AACH,GA/GuB,CAiHxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAQ,EAAAA,MAAM,CAACC,MAAD,EAAS;AACX,SAAKlB,OAAL,CAAaiB,MAAb,CAAoBC,MAApB;AACH;;AAvMuB","sourcesContent":["import {Text} from \"./simple/text\";\nimport {Circle} from \"./simple/circle\";\nimport {Rectangle} from \"./simple/rectangle\";\nimport {DrawBox} from \"./draw-box\";\nimport {HLine, Line} from \"./simple/line\";\nimport {ExtendedHVector, ExtendedLine, ExtendedVector, ExtendedVLine} from \"./extended/extended-line\";\nimport {Node} from \"./extended/node\";\nimport {Caption} from \"./extended/caption\";\n\nexport class DrawBoxHandler {\n    const\n    METHOD_POINTERS = {\n        text: () => new Text(),\n        circle: () => new Circle(),\n        line: () => new ExtendedLine(this),\n        rect: () => new Rectangle(),\n        node: () => new Node(this),\n        cap: () => new Caption(this),\n        hline: () => new ExtendedLine(this),\n        vline: () => new ExtendedVLine(this),\n        vect: () => new ExtendedVector(this),\n        hvect: () => new ExtendedHVector(this),\n        label: (d, o) => {typeof d ==='string'?o.setLabel(d):o.setLabel()},\n        color: (d, o) => o.setColor(d),\n        fillColor: (d, o) => o.setFillColor(d),\n        strokeColor: (d, o) => o.setStrokeColor(d),\n        strokeWidth: (d, o) => o.setStrokeWidth(d),\n        strokeStyle: (d, o) => o.setStrokeStyle(d),\n        radius: (d, o) => o.setRadius(d),\n        fontSize: (d, o) => o.setFontSize(d),\n        fontStyle: (d, o) => o.setFontStyle(d),\n        lineto: (d, o) => o.lineto(d),\n        arrow: (d, o) => o.showArrow(d[0], d[1]),\n        len: (d, o) => o.setLength(d),\n        between: (d, o) => o.between(d),\n        width: (d, o) => o.setWidth(d),\n        height: (d, o) => o.setHeight(d),\n        conn: (d, o) => o.connectTo(d),\n        captions: (d, o) => o.setCaptions(d),\n    };\n\n    constructor() {\n        this.drawBox = new DrawBox();\n        this.container = {};\n    }\n\n    /**\n     * @param itemConf it is an object with fields:<br/>\n     * {\n     *    shape: ['text', 'circle', 'line', 'rect', 'node', 'cap', 'hline', 'vline', 'vect', 'hvect']<br/>\n     *\n     *    --- generic ------<br/>\n     *    id: string<br/>\n     *    pos: [x, y]<br/>\n     *    align: shape<br/>\n     *    offset: [dx, dy]<br/>\n     *    label: [string, Text-object<br/>\n     *    color: ['green', 'blue', 'red', 'yellow', 'purple', 'brown', 'orange', 'pink'], (set fill & stroke together)<br/>\n     *    fillColor: color<br/>\n     *    strokeColor: color<br/>\n     *    strokeWidth: int<br/>\n     *    strokeStyle: [int, int], (make stroke dashed)<br/>\n     *\n     *    --- circle ------<br/>\n     *    radius: int<br/>\n     *\n     *    --- Text ------<br/>\n     *    fontSize: value, (ex. '20px' or '12em'<br/>\n     *    fontStyle: ['bold', 'italic', 'bold italic'<br/>\n     *\n     *    --- all line types ------<br/>\n     *    lineto: [x,y] or [intR, length] or [intD, length]<br/>\n     *    arrow: [dir([true, false]), places([0 - 1])]<br/>\n     *    between: [id1, id2, gap]<br/>\n     *\n     *    --- hline & vline & hvect ------<br/>\n     *    len: int<br/>\n     *\n     *    --- rectangle ------<br/>\n     *    width: int<br/>\n     *    height: int<br/>\n     *\n     *    --- node & cap ------<br/>\n     *    conn: ref-id. (connect to the aligned shape)<br/>\n     *    captions: [{t:string, c: 'color string', w:width, offset:[x=0,y=0]}]<br/>\n     * }\n     */\n    addShape(itemConf) {\n        this.drawBox.addShape(this.generateShape(itemConf));\n        return this;\n    }\n\n    generateShape(itemConf) {\n        debugger\n        let o = this.METHOD_POINTERS[itemConf.shape](itemConf);\n        this.initShape(itemConf, o);\n        let t;\n        for (t in itemConf) {\n            if (t !== 'shape' && t !== 'id' && t !== 'pos' && t !== 'align' && t !== 'offset') {\n                this.METHOD_POINTERS[t](itemConf[t], o);\n            }\n        }\n        return o;\n    }\n\n    initShape(conf, o) {\n        if (conf.id)\n            this.container[conf.id] = o;\n        if (conf.pos)\n            o.setPosition(conf.pos);\n        if (conf.align)\n            o.alignTo(this.container[conf.align]);\n        if (conf.offset) {\n            o.setOffset(conf.offset);\n        }\n        return o;\n    }\n\n    getTargetShape(id){\n        return this.container[id];\n    }\n\n    // generateNode() {\n    //     //crate new circle\n    //     let o = new Circle()\n    //         .setRadius(20)\n    //         .setStrokeWidth(3)\n    //         .setStrokeColor('black')\n    //         .setFillColor('yellow');\n    //\n    //     //redirect setLabel to a new method\n    //     this.applyCustomLabel(o, lbl =>\n    //         new Text()\n    //             .setPosition(o.getCenterPoint())\n    //             .setLabel(lbl)\n    //             .setFontSize('20px')\n    //             .setOffset([0, 6]));\n    //     o['connectTo'] = refId => {\n    //         this.drawBox.addShape(this.generateVector()\n    //             .superBetween(o, this.container[refId], 5));\n    //         return o;\n    //     };\n    //     o['setCaptions'] = caps => {\n    //         if (caps[0] === undefined)\n    //             caps = [caps];\n    //         caps.forEach((v, i) => {\n    //             this.drawBox.addShape(\n    //                 this.generateCaption()\n    //                     .alignTo(o)\n    //                     .setOffset(v.offset ? v.offset : [28, (caps.length * -11.5 + (i * 25))])\n    //                     .setWidth(v.w)\n    //                     .setHeight(20)\n    //                     .setLabel(v.t)\n    //                     .setColor(v.c)\n    //                     .setStrokeWidth(2)\n    //             )\n    //         })\n    //         return o;\n    //     };\n    //     return o;\n    // }\n    //\n    // generateCaption() {\n    //     let o = new Rectangle()\n    //     this.applyCustomLabel(o, lbl =>\n    //         new Text()\n    //             .setPosition(o.getCenterPoint())\n    //             .setLabel(lbl)\n    //             .setOffset([0, 5])\n    //             .setFontStyle('bold'));\n    //     o['connectTo'] = refId => {\n    //         this.drawBox.addShape(new Line()\n    //             .between(o, this.container[refId], 5)\n    //             .setStrokeColor('red')\n    //             .setFillColor('red')\n    //             .setStrokeWidth(1));\n    //         return o;\n    //     };\n    //     return o;\n    // }\n    //\n    // generateLine(labelProducer = null) {\n    //     let o = new Line();\n    //     o['superBetween'] = o.between;\n    //     o[\"between\"] = data => o.superBetween(this.container[data[0]], this.container[data[1]], data[2]);\n    //     this.applyCustomLabel(o, labelProducer);\n    //     return o;\n    // }\n    //\n    // prepareLine(o){\n    //     o['superBetween'] = o.between;\n    //     o[\"between\"] = data => o.superBetween(this.container[data[0]], this.container[data[1]], data[2]);\n    //     this.applyCustomLabel(o);\n    //     return o;\n    // }\n    //\n    //\n    // applyCustomLabel(shape, textModifier = null) {\n    //     shape['setText'] = shape.setLabel;\n    //     shape['setLabel'] = lbl => {\n    //         return (typeof lbl === 'string') ?\n    //             shape.setText(textModifier ? textModifier(lbl) : lbl) :\n    //             shape.setText(this.generateShape(lbl).alignTo(shape))\n    //     };\n    // }\n\n    render(canvas) {\n        this.drawBox.render(canvas);\n    }\n}"]},"metadata":{},"sourceType":"module"}