{"ast":null,"code":"import { Shape } from \"./shape\";\nimport { Line } from \"./line\";\nexport class Path extends Shape {\n  constructor() {\n    super();\n    this.points = [];\n    this.setStrokeWidth(1);\n  }\n  /**\n   * @param point [x,y,ox,oy]\n   */\n\n\n  moveTo(point) {\n    this.points.push({\n      type: 'm',\n      point: point\n    });\n    return this;\n  }\n  /**\n   * @param point [x,y,ox,oy] or [intR,length,ox,oy] for radian, [intD,length,ox,oy] for degree or [shape,gap,ox,oy].<br/>\n   */\n\n\n  lineTo(point) {\n    this.points.push({\n      type: 'l',\n      point: new Line().setEnd(point)\n    });\n    return this;\n  }\n  /**\n   * @param curve [x,y,ox,oy] or [intR,length,ox,oy] for radian, [intD,length,ox,oy] for degree or [shape,gap,ox,oy].<br/>\n   * @param end [x,y,ox,oy] or [intR,length,ox,oy] for radian, [intD,length,ox,oy] for degree or [shape,gap,ox,oy].<br/>\n   */\n\n\n  quadraticTo(curve, end) {\n    this.points.push({\n      type: 'l',\n      point: new Line().setQuadraticPoint(curve).setEnd(end)\n    });\n    return this;\n  }\n  /**\n   * show arrows on the line\n   * @param direction 0 or 1\n   * @param places array of float values, each is 0 - 1;\n   * @return Shape\n   */\n\n\n  showArrow(direction, places) {\n    this.direction = direction;\n    this.places = typeof places === 'number' ? [places] : places;\n    return this;\n  }\n\n  render(canvasCtx) {\n    this.prepareLines();\n\n    for (let i = 1; i < this.points.length; i++) {\n      this.points[i].render(canvasCtx);\n    }\n  }\n\n  prepareLines() {\n    let lines = this.getLines(); //deter mine arrow position\n\n    if (this.places != null && this.places.length > 0) {\n      let repo = this.getDistributedArrowPlaces(lines);\n\n      for (let k in repo) {\n        lines[repo[k].key + 1].showArrow(this.direction, repo[k].items);\n      }\n    }\n  }\n\n  getLines() {\n    let lines = [];\n    lines.push({\n      line: null,\n      len: 0\n    });\n    let temp = null,\n        line,\n        len;\n\n    for (let i = 0; i < this.points.length; i++) {\n      if (this.points[i].type === 'm') {\n        temp = this.points[i].point;\n      } else {\n        line = this.points[i].point;\n        line.setStart(temp != null ? temp : lines[lines.length - 1].line.getEnd());\n        temp = null;\n        line.setOffset(this.offset);\n        this.initLine(line);\n        len = line.getLength() + lines[lines.length - 1].len;\n        lines.push({\n          line: line,\n          len: len\n        });\n      }\n    }\n\n    return lines;\n  }\n\n  getDistributedArrowPlaces(lines) {\n    let max = lines[lines.length - 1].len;\n    let p,\n        temp,\n        repo = [];\n\n    for (let i = 0; i < this.places.length; i++) {\n      p = this.places[i] * max;\n\n      for (let j = 0; j < lines.length - 1; j++) {\n        if (p >= lines[j].len && p <= lines[j + 1].len) {\n          temp = this.getRepoObject(repo, j);\n          temp.items.push((p - lines[j].len) / (lines[j + 1].len - lines[j].len));\n          break;\n        }\n      }\n    }\n\n    return repo;\n  }\n\n  getRepoObject(repo, key) {\n    if (repo[key] == null) repo[key] = {\n      key: key,\n      items: [],\n      places: []\n    };\n    return repo[key];\n  }\n\n  initLine(line) {\n    line.setFillColor(this.fillColor);\n    line.setStrokeColor(this.strokeColor);\n    line.setStrokeWidth(this.strokeWidth);\n    line.setStrokeStyle(this.strokeStyle);\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/simple/path.js"],"names":["Shape","Line","Path","constructor","points","setStrokeWidth","moveTo","point","push","type","lineTo","setEnd","quadraticTo","curve","end","setQuadraticPoint","showArrow","direction","places","render","canvasCtx","prepareLines","i","length","lines","getLines","repo","getDistributedArrowPlaces","k","key","items","line","len","temp","setStart","getEnd","setOffset","offset","initLine","getLength","max","p","j","getRepoObject","setFillColor","fillColor","setStrokeColor","strokeColor","strokeWidth","setStrokeStyle","strokeStyle"],"mappings":"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","sourcesContent":["import {Shape} from \"./shape\";\nimport {Line} from \"./line\";\n\nexport class Path extends Shape {\n    points = [];\n\n    constructor() {\n        super();\n        this.setStrokeWidth(1);\n    }\n\n    /**\n     * @param point [x,y,ox,oy]\n     */\n    moveTo(point) {\n        this.points.push({type: 'm', point: point});\n        return this;\n    }\n\n    /**\n     * @param point [x,y,ox,oy] or [intR,length,ox,oy] for radian, [intD,length,ox,oy] for degree or [shape,gap,ox,oy].<br/>\n     */\n    lineTo(point) {\n        this.points.push({type: 'l', point: new Line().setEnd(point)});\n        return this;\n    }\n\n    /**\n     * @param curve [x,y,ox,oy] or [intR,length,ox,oy] for radian, [intD,length,ox,oy] for degree or [shape,gap,ox,oy].<br/>\n     * @param end [x,y,ox,oy] or [intR,length,ox,oy] for radian, [intD,length,ox,oy] for degree or [shape,gap,ox,oy].<br/>\n     */\n    quadraticTo(curve, end) {\n        this.points.push({type: 'l', point: new Line().setQuadraticPoint(curve).setEnd(end)});\n        return this;\n    }\n\n    /**\n     * show arrows on the line\n     * @param direction 0 or 1\n     * @param places array of float values, each is 0 - 1;\n     * @return Shape\n     */\n    showArrow(direction, places) {\n        this.direction = direction;\n        this.places = typeof places === 'number' ? [places] : places;\n        return this;\n    }\n\n    render(canvasCtx) {\n        this.prepareLines();\n        for (let i = 1; i < this.points.length; i++) {\n            this.points[i].render(canvasCtx);\n        }\n    }\n\n    prepareLines() {\n        let lines = this.getLines();\n\n        //deter mine arrow position\n        if (this.places != null && this.places.length > 0) {\n            let repo = this.getDistributedArrowPlaces(lines);\n            for (let k in repo) {\n                lines[repo[k].key + 1].showArrow(this.direction, repo[k].items);\n            }\n        }\n    }\n\n    getLines() {\n        let lines = [];\n        lines.push({line: null, len: 0});\n\n        let temp = null, line, len;\n        for (let i = 0; i < this.points.length; i++) {\n            if (this.points[i].type === 'm') {\n                temp = this.points[i].point;\n            } else {\n                line = this.points[i].point;\n                line.setStart(temp != null ? temp : lines[lines.length - 1].line.getEnd());\n                temp = null;\n                line.setOffset(this.offset);\n                this.initLine(line);\n                len = line.getLength() + lines[lines.length - 1].len;\n                lines.push({line: line, len: len});\n            }\n        }\n        return lines;\n    }\n\n    getDistributedArrowPlaces(lines) {\n        let max = lines[lines.length - 1].len;\n        let p, temp, repo = [];\n        for (let i = 0; i < this.places.length; i++) {\n            p = this.places[i] * max;\n            for (let j = 0; j < lines.length - 1; j++) {\n                if (p >= lines[j].len && p <= lines[j + 1].len) {\n                    temp = this.getRepoObject(repo, j);\n                    temp.items.push((p - lines[j].len) / (lines[j + 1].len - lines[j].len));\n                    break;\n                }\n            }\n        }\n        return repo;\n    }\n\n    getRepoObject(repo, key) {\n        if (repo[key] == null)\n            repo[key] = {key: key, items: [], places: []};\n        return repo[key];\n    }\n\n    initLine(line) {\n        line.setFillColor(this.fillColor);\n        line.setStrokeColor(this.strokeColor);\n        line.setStrokeWidth(this.strokeWidth);\n        line.setStrokeStyle(this.strokeStyle);\n    }\n}"]},"metadata":{},"sourceType":"module"}