{"ast":null,"code":"import { Shape } from \"./shape\";\nimport { Utils } from \"../../../tools/utils\";\nimport { Text } from \"./text\";\nexport class Line extends Shape {\n  constructor() {\n    super();\n    this.path = [];\n    this.setStrokeWidth(1);\n  }\n\n  setPosition(position) {\n    return this.addPoint(position, 0);\n  }\n\n  addPoint(point, index = null) {\n    if (index == null) {\n      this.path.push(this.getPoint(point));\n    } else {\n      for (let i = this.path.length; i > index; i--) this.path[i] = this.path[i - 1];\n\n      this.path[index] = this.getPoint(point);\n    }\n\n    return this;\n  }\n  /**\n   * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n   * you can have m & n before point location to make the line curvy:<br/>\n   * ex.<br/>\n   * [4, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [4, 5] in curvy shape<br/>\n   * [90d, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [90d, 5] in curvy shape<br/>\n   * [1r, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [1r, 5] in curvy shape<br/>\n   * [shape, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [shape, 5] in curvy shape<br/>\n   *\n   */\n\n\n  getPoint(point) {\n    let ans = {};\n    let p, c;\n\n    if (point[2] != null && point[3] != null) {\n      p = [point[2], point[3]];\n      c = [point[0], point[1]];\n    } else {\n      p = [point[0], point[1]];\n    }\n\n    switch (this.getTypeOf(p)) {\n      case \"number,number\":\n        //[x,y]\n        ans[\"xy\"] = p;\n        break;\n\n      case \"string,number\":\n        //[intR,length] or [intD,length]\n        let i = p[0].length - 1;\n        let c = p[0][i];\n        let v = Number(p[0].substring(0, i));\n\n        if (c === 'R' || c === 'r') {\n          ans[\"angle\"] = Utils.normalizeRadian(v);\n          ans[\"gap\"] = p[1];\n        } else if (c === 'D' || c === 'd') {\n          ans[\"angle\"] = Utils.normalizeRadian(Utils.deg2Rad(v));\n          ans[\"gap\"] = p[1];\n        } else {\n          throw new Error('wrong input');\n        }\n\n        break;\n\n      case \"object,number\":\n        //[shape,gap]\n        ans[\"shape\"] = p[0];\n        ans[\"gap\"] = p[1];\n        break;\n\n      default:\n        throw new Error('wrong input');\n    }\n\n    if (c != null) {\n      ans[\"curve\"] = this.getPoint(c);\n    }\n\n    return ans;\n  }\n\n  getTypeOf(point) {\n    return typeof point[0] + ',' + typeof point[1];\n  }\n\n  preparePoints() {\n    let p;\n\n    for (let i = 1; i < this.path.length; i++) {\n      p = this.path[i];\n\n      if (p[\"xy\"] == null) {\n        // no xy\n        if (p[\"shape\"] != null && p[\"curve\"] != null) {\n          // is a shape and has a curve point\n          this.calculateTargetPoint(p, p[\"curve\"]); // find xy by curve\n\n          let p2 = this.path[i - 1];\n\n          if (p2[\"xy\"] == null) {\n            this.calculatePreviousPoint(p2, Utils.getAngle(p2[\"shape\"].getCenterPoint()));\n          }\n        } else {\n          //find xy by previous point\n          this.calculateTargetPoint(p, this.path[i - 1]);\n        }\n      }\n    }\n  }\n\n  calculatePreviousPoint(point, angle) {}\n  /**\n   * call this when point is a shape\n   * @param point\n   * @param helper\n   */\n\n\n  calculateTargetPoint(point, helper) {\n    if (helper[\"angle\"] != null) {\n      point[\"angle\"] = Math.PI - helper[\"angle\"];\n    } else {\n      let c1 = point[\"shape\"].getCenterPoint();\n      let c2 = helper[\"xy\"] != null ? helper[\"xy\"] : helper[\"shape\"].getCenterPoint();\n      point[\"angle\"] = Utils.getAngle(c1[0], c1[1], c2[0], c2[1]);\n    }\n\n    point[\"xy\"] = point[\"shape\"][\"getExternalPoint\"] != null ? point[\"shape\"].getExternalPoint(point[\"angle\"], point[\"gap\"]) : point[\"shape\"].getCenterPoint();\n  }\n\n  preprocessPoints(point1, point2) {\n    if (point2[\"angle\"] == null) {\n      let p1 = point1[\"xy\"] != null ? point1[\"xy\"] : point1[\"shape\"].getCenterPoint();\n      let p2 = point2[\"xy\"] != null ? point2[\"xy\"] : point2[\"shape\"].getCenterPoint();\n      point2[\"angle\"] = Utils.getAngle(p2[0], p2[1], p1[0], p1[1]);\n    }\n\n    if (point1[\"xy\"] == null) {\n      point1[\"xy\"] = this.getTargetPointOfShape(point1, Math.PI - point2[\"angle\"], point1[\"gap\"]);\n    }\n\n    if (point2[\"xy\"] == null) {\n      try {\n        point2[\"xy\"] = this.getTargetPointOfShape(point2, point2[\"angle\"], point2[\"gap\"]);\n      } catch (e) {\n        point2[\"xy\"] = [point1[\"xy\"][0] + point2[\"gap\"] * Math.cos(point2[\"angle\"]), point1[\"xy\"][1] + point2[\"gap\"] * Math.sin(point2[\"angle\"])];\n      }\n    }\n  }\n\n  getTargetPointOfShape(point, angle, gap = 0) {\n    if (point[\"shape\"] != null) {\n      if (point[\"shape\"][\"getExternalPoint\"] != null) {\n        return point[\"shape\"].getExternalPoint(angle, gap);\n      } else {\n        let m = point[\"shape\"].getCenterPoint();\n        return [m[0] + gap * Math.cos(angle), m[1] + gap * Math.sin(angle)];\n      }\n    }\n\n    throw new Error('the point is not a shape');\n  }\n\n  render(canvasCtx) {\n    debugger;\n    this.preparePoints();\n    canvasCtx.beginPath();\n    let p = this.path[0];\n    canvasCtx.moveTo(p[\"xy\"][0], p[\"xy\"][1]);\n\n    for (let i = 1; i < this.path.length; i++) {\n      p = this.path[i];\n      if (p[\"curve\"] != null) canvasCtx.quadraticCurveTo(p[\"curve\"][\"xy\"][0], p[\"curve\"][\"xy\"][1], p[\"xy\"][0], p[\"xy\"][1]);else canvasCtx.lineTo(p[\"xy\"][0], p[\"xy\"][1]);\n    } // canvasCtx.closePath();\n\n\n    super.render(canvasCtx);\n  } // getNeighbourPoint(point) {\n  //     let index;\n  //     for (index = 0; index < this.path.length; index++) if (this.path[index] === point) break\n  //     return index === 0 ? this.path[1] : this.path[index - 1];\n  // }\n  //\n  // /**\n  //  * @param shape1 shape 1\n  //  * @param shape2 shape 2\n  //  * @param gap the gap between line and target shapes. gap>=0\n  //  */\n  // between(shape1, shape2, gap = 0) {\n  //     let c1 = shape1.getCenterPoint();\n  //     let c2 = shape2.getCenterPoint();\n  //     c1 = shape1.getExternalPoint(Utils.getAngle(c1[0], c1[1], c2[0], c2[1]), gap);\n  //     c2 = shape2.getExternalPoint(Utils.getAngle(c2[0], c2[1], c1[0], c1[1]), gap);\n  //     this.setPosition(c1);\n  //     this.lineTo(c2);\n  //     return this;\n  // }\n  //\n  // /**\n  //  * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or shape\n  //  */\n  // lineTo(point) {\n  //     if (typeof point[0] === 'string') {\n  //         let i = point[0].length - 1;\n  //         let c = point[0][i];\n  //         let v = Number(point[0].substring(0, i));\n  //         if (c === 'R' || c === 'r') {\n  //             this.secondP = this.getTargetPoint(v, point[1]);\n  //         } else if (c === 'D' || c === 'd') {\n  //             this.secondP = this.getTargetPoint(Utils.deg2Rad(v), point[1]);\n  //         } else {\n  //             throw new Error('wrong input');\n  //         }\n  //     } else {\n  //         this.secondP = point;\n  //     }\n  //     return this;\n  // }\n  //\n  // getTargetPoint(r, d) {\n  //     let p = this.getPosition();\n  //     return [p[0] + Math.cos(r) * d, p[1] + Math.sin(r) * d];\n  // }\n\n\n  getCenterPoint() {\n    let p = this.getPosition();\n    return [(p[0] + this.secondP[0]) / 2, (p[1] + this.secondP[1]) / 2];\n  }\n  /**\n   * show arrows on the line\n   * @param direction 0 or 1\n   * @param places array of float values, each is 0 - 1;\n   * @return Shape\n   */\n\n\n  showArrow(direction, places) {\n    this.direction = direction;\n    this.places = places;\n    return this;\n  }\n\n  drawArrow(canvasCtx, length, angle, x, y) {\n    canvasCtx.beginPath();\n    let p1 = [x + length * Math.cos(angle - Utils._PI6), y + length * Math.sin(angle - Utils._PI6)];\n    let p2 = [x + length * Math.cos(angle + Utils._PI6), y + length * Math.sin(angle + Utils._PI6)];\n    canvasCtx.moveTo(x, y);\n    canvasCtx.lineTo(p1[0], p1[1]);\n    canvasCtx.lineTo(p2[0], p2[1]);\n    canvasCtx.closePath();\n    super.render(canvasCtx);\n  } // render(canvasCtx) {\n  //     let p1 = this.getPosition();\n  //     canvasCtx.beginPath();\n  //     canvasCtx.moveTo(p1[0], p1[1]);\n  //     canvasCtx.lineTo(this.secondP[0], this.secondP[1]);\n  //     canvasCtx.closePath();\n  //     super.render(canvasCtx);\n  //     if (this.direction !== undefined && this.places !== undefined) {\n  //         if (!this.places[0])\n  //             this.places = [this.places];\n  //         let angle = this.direction ? Utils.getAngle(this.secondP[0], this.secondP[1], p1[0], p1[1]) : Utils.getAngle(p1[0], p1[1], this.secondP[0], this.secondP[1]);\n  //         for (let i = 0; i < this.places.length; i++) {\n  //             let x = p1[0] + (this.secondP[0] - p1[0]) * this.places[i];\n  //             let y = p1[1] + (this.secondP[1] - p1[1]) * this.places[i];\n  //             this.drawArrow(canvasCtx, 10, angle, x, y);\n  //         }\n  //     }\n  // }\n\n\n}\nexport class HLine extends Line {\n  setLength(l) {\n    l > 0 ? this.lineTo(['0D', l]) : this.lineTo(['180D', -l]);\n    return this;\n  }\n\n}\nexport class VLine extends Line {\n  setLength(l) {\n    l > 0 ? this.lineTo(['90D', l]) : this.lineTo(['270D', -l]);\n    return this;\n  }\n\n}\nexport class Vector extends Line {\n  constructor() {\n    super();\n    this.setStrokeColor('black').setFillColor('black').setStrokeWidth(2).showArrow(1, 1);\n  }\n\n}\nexport class HVector extends Vector {\n  setLabel(label) {\n    if (typeof label === 'string') label = new Text().setPosition(this.getCenterPoint()).setLabel(label).setOffset([0, -6]).setFontStyle('');\n    return super.setLabel(label);\n  }\n\n  setLength(l) {\n    return l > 0 ? this.lineTo(['0D', l]) : this.lineTo(['180D', -l]);\n  }\n\n}","map":{"version":3,"sources":["/media/arash/SanDisk/MyCheatBook/src/components/drawbox/simple/line.js"],"names":["Shape","Utils","Text","Line","constructor","path","setStrokeWidth","setPosition","position","addPoint","point","index","push","getPoint","i","length","ans","p","c","getTypeOf","v","Number","substring","normalizeRadian","deg2Rad","Error","preparePoints","calculateTargetPoint","p2","calculatePreviousPoint","getAngle","getCenterPoint","angle","helper","Math","PI","c1","c2","getExternalPoint","preprocessPoints","point1","point2","p1","getTargetPointOfShape","e","cos","sin","gap","m","render","canvasCtx","beginPath","moveTo","quadraticCurveTo","lineTo","getPosition","secondP","showArrow","direction","places","drawArrow","x","y","_PI6","closePath","HLine","setLength","l","VLine","Vector","setStrokeColor","setFillColor","HVector","setLabel","label","setOffset","setFontStyle"],"mappings":"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","sourcesContent":["import {Shape} from \"./shape\";\nimport {Utils} from \"../../../tools/utils\";\nimport {Text} from \"./text\";\n\nexport class Line extends Shape {\n    path = [];\n\n    constructor() {\n        super();\n        this.setStrokeWidth(1);\n    }\n\n    setPosition(position) {\n        return this.addPoint(position, 0);\n    }\n\n    addPoint(point, index = null) {\n        if (index == null) {\n            this.path.push(this.getPoint(point));\n        } else {\n            for (let i = this.path.length; i > index; i--)\n                this.path[i] = this.path[i - 1];\n            this.path[index] = this.getPoint(point);\n        }\n        return this;\n    }\n\n    /**\n     * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or [shape,gap].<br/>\n     * you can have m & n before point location to make the line curvy:<br/>\n     * ex.<br/>\n     * [4, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [4, 5] in curvy shape<br/>\n     * [90d, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [90d, 5] in curvy shape<br/>\n     * [1r, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [1r, 5] in curvy shape<br/>\n     * [shape, 5, 2, 3]: point itself is located at [2, 3] and the line between this point and the previous one will pass from [shape, 5] in curvy shape<br/>\n     *\n     */\n    getPoint(point) {\n        let ans = {};\n        let p, c;\n        if (point[2] != null && point[3] != null) {\n            p = [point[2], point[3]];\n            c = [point[0], point[1]];\n        } else {\n            p = [point[0], point[1]];\n        }\n        switch (this.getTypeOf(p)) {\n            case \"number,number\"://[x,y]\n                ans[\"xy\"] = p;\n                break;\n            case \"string,number\"://[intR,length] or [intD,length]\n                let i = p[0].length - 1;\n                let c = p[0][i];\n                let v = Number(p[0].substring(0, i));\n                if (c === 'R' || c === 'r') {\n                    ans[\"angle\"] = Utils.normalizeRadian(v);\n                    ans[\"gap\"] = p[1];\n                } else if (c === 'D' || c === 'd') {\n                    ans[\"angle\"] = Utils.normalizeRadian(Utils.deg2Rad(v));\n                    ans[\"gap\"] = p[1];\n                } else {\n                    throw new Error('wrong input');\n                }\n                break;\n            case \"object,number\"://[shape,gap]\n                ans[\"shape\"] = p[0];\n                ans[\"gap\"] = p[1];\n                break;\n            default:\n                throw new Error('wrong input');\n        }\n        if (c != null) {\n            ans[\"curve\"] = this.getPoint(c);\n        }\n        return ans;\n    }\n\n    getTypeOf(point) {\n        return typeof point[0] + ',' + typeof point[1]\n    }\n\n    preparePoints() {\n        let p;\n        for (let i = 1; i < this.path.length; i++) {\n            p = this.path[i];\n            if (p[\"xy\"] == null) { // no xy\n                if (p[\"shape\"] != null && p[\"curve\"] != null) { // is a shape and has a curve point\n                    this.calculateTargetPoint(p, p[\"curve\"]); // find xy by curve\n                    let p2 = this.path[i - 1];\n                    if(p2[\"xy\"]==null) {\n\n                        this.calculatePreviousPoint(p2, Utils.getAngle(p2[\"shape\"].getCenterPoint()))\n                    }\n                } else { //find xy by previous point\n                    this.calculateTargetPoint(p, this.path[i - 1]);\n                }\n\n            }\n        }\n    }\n\n    calculatePreviousPoint(point,angle){\n\n    }\n\n    /**\n     * call this when point is a shape\n     * @param point\n     * @param helper\n     */\n    calculateTargetPoint(point, helper) {\n        if (helper[\"angle\"] != null) {\n            point[\"angle\"] = Math.PI - helper[\"angle\"];\n        } else {\n            let c1 = point[\"shape\"].getCenterPoint();\n            let c2 = helper[\"xy\"] != null ? helper[\"xy\"] : helper[\"shape\"].getCenterPoint();\n            point[\"angle\"] = Utils.getAngle(c1[0], c1[1], c2[0], c2[1]);\n        }\n        point[\"xy\"] = point[\"shape\"][\"getExternalPoint\"] != null ?\n            point[\"shape\"].getExternalPoint(point[\"angle\"], point[\"gap\"]) :\n            point[\"shape\"].getCenterPoint();\n    }\n\n    preprocessPoints(point1, point2) {\n        if (point2[\"angle\"] == null) {\n            let p1 = point1[\"xy\"] != null ? point1[\"xy\"] : point1[\"shape\"].getCenterPoint();\n            let p2 = point2[\"xy\"] != null ? point2[\"xy\"] : point2[\"shape\"].getCenterPoint();\n            point2[\"angle\"] = Utils.getAngle(p2[0], p2[1], p1[0], p1[1]);\n        }\n\n        if (point1[\"xy\"] == null) {\n            point1[\"xy\"] = this.getTargetPointOfShape(point1, Math.PI - point2[\"angle\"], point1[\"gap\"])\n        }\n\n        if (point2[\"xy\"] == null) {\n            try {\n                point2[\"xy\"] = this.getTargetPointOfShape(point2, point2[\"angle\"], point2[\"gap\"])\n            } catch (e) {\n                point2[\"xy\"] = [point1[\"xy\"][0] + point2[\"gap\"] * Math.cos(point2[\"angle\"]), point1[\"xy\"][1] + point2[\"gap\"] * Math.sin(point2[\"angle\"])];\n            }\n        }\n    }\n\n    getTargetPointOfShape(point, angle, gap = 0) {\n        if (point[\"shape\"] != null) {\n            if (point[\"shape\"][\"getExternalPoint\"] != null) {\n                return point[\"shape\"].getExternalPoint(angle, gap);\n            } else {\n                let m = point[\"shape\"].getCenterPoint();\n                return [m[0] + gap * Math.cos(angle), m[1] + gap * Math.sin(angle)];\n            }\n        }\n        throw new Error('the point is not a shape');\n    }\n\n    render(canvasCtx) {\n        debugger\n        this.preparePoints();\n        canvasCtx.beginPath();\n        let p = this.path[0];\n        canvasCtx.moveTo(p[\"xy\"][0], p[\"xy\"][1]);\n        for (let i = 1; i < this.path.length; i++) {\n            p = this.path[i];\n            if (p[\"curve\"] != null)\n                canvasCtx.quadraticCurveTo(p[\"curve\"][\"xy\"][0], p[\"curve\"][\"xy\"][1], p[\"xy\"][0], p[\"xy\"][1]);\n            else\n                canvasCtx.lineTo(p[\"xy\"][0], p[\"xy\"][1]);\n        }\n        // canvasCtx.closePath();\n        super.render(canvasCtx);\n    }\n\n    // getNeighbourPoint(point) {\n    //     let index;\n    //     for (index = 0; index < this.path.length; index++) if (this.path[index] === point) break\n    //     return index === 0 ? this.path[1] : this.path[index - 1];\n    // }\n    //\n    // /**\n    //  * @param shape1 shape 1\n    //  * @param shape2 shape 2\n    //  * @param gap the gap between line and target shapes. gap>=0\n    //  */\n    // between(shape1, shape2, gap = 0) {\n    //     let c1 = shape1.getCenterPoint();\n    //     let c2 = shape2.getCenterPoint();\n    //     c1 = shape1.getExternalPoint(Utils.getAngle(c1[0], c1[1], c2[0], c2[1]), gap);\n    //     c2 = shape2.getExternalPoint(Utils.getAngle(c2[0], c2[1], c1[0], c1[1]), gap);\n    //     this.setPosition(c1);\n    //     this.lineTo(c2);\n    //     return this;\n    // }\n    //\n    // /**\n    //  * @param point [x,y] or [intR, length] for radian, [intD, length] for degree or shape\n    //  */\n    // lineTo(point) {\n    //     if (typeof point[0] === 'string') {\n    //         let i = point[0].length - 1;\n    //         let c = point[0][i];\n    //         let v = Number(point[0].substring(0, i));\n    //         if (c === 'R' || c === 'r') {\n    //             this.secondP = this.getTargetPoint(v, point[1]);\n    //         } else if (c === 'D' || c === 'd') {\n    //             this.secondP = this.getTargetPoint(Utils.deg2Rad(v), point[1]);\n    //         } else {\n    //             throw new Error('wrong input');\n    //         }\n    //     } else {\n    //         this.secondP = point;\n    //     }\n    //     return this;\n    // }\n    //\n    // getTargetPoint(r, d) {\n    //     let p = this.getPosition();\n    //     return [p[0] + Math.cos(r) * d, p[1] + Math.sin(r) * d];\n    // }\n\n    getCenterPoint() {\n        let p = this.getPosition();\n        return [(p[0] + this.secondP[0]) / 2, (p[1] + this.secondP[1]) / 2]\n    }\n\n    /**\n     * show arrows on the line\n     * @param direction 0 or 1\n     * @param places array of float values, each is 0 - 1;\n     * @return Shape\n     */\n    showArrow(direction, places) {\n        this.direction = direction;\n        this.places = places;\n        return this;\n    }\n\n    drawArrow(canvasCtx, length, angle, x, y) {\n        canvasCtx.beginPath();\n        let p1 = [x + length * Math.cos(angle - Utils._PI6), y + length * Math.sin(angle - Utils._PI6)];\n        let p2 = [x + length * Math.cos(angle + Utils._PI6), y + length * Math.sin(angle + Utils._PI6)];\n        canvasCtx.moveTo(x, y);\n        canvasCtx.lineTo(p1[0], p1[1]);\n        canvasCtx.lineTo(p2[0], p2[1]);\n        canvasCtx.closePath();\n        super.render(canvasCtx);\n    }\n\n    // render(canvasCtx) {\n    //     let p1 = this.getPosition();\n    //     canvasCtx.beginPath();\n    //     canvasCtx.moveTo(p1[0], p1[1]);\n    //     canvasCtx.lineTo(this.secondP[0], this.secondP[1]);\n    //     canvasCtx.closePath();\n    //     super.render(canvasCtx);\n    //     if (this.direction !== undefined && this.places !== undefined) {\n    //         if (!this.places[0])\n    //             this.places = [this.places];\n    //         let angle = this.direction ? Utils.getAngle(this.secondP[0], this.secondP[1], p1[0], p1[1]) : Utils.getAngle(p1[0], p1[1], this.secondP[0], this.secondP[1]);\n    //         for (let i = 0; i < this.places.length; i++) {\n    //             let x = p1[0] + (this.secondP[0] - p1[0]) * this.places[i];\n    //             let y = p1[1] + (this.secondP[1] - p1[1]) * this.places[i];\n    //             this.drawArrow(canvasCtx, 10, angle, x, y);\n    //         }\n    //     }\n    // }\n}\n\nexport class HLine\n    extends Line {\n    setLength(l) {\n        l > 0 ?\n            this.lineTo(['0D', l]) :\n            this.lineTo(['180D', -l])\n        return this;\n    }\n}\n\nexport class VLine extends Line {\n    setLength(l) {\n        l > 0 ?\n            this.lineTo(['90D', l]) :\n            this.lineTo(['270D', -l])\n        return this;\n    }\n}\n\nexport class Vector extends Line {\n    constructor() {\n        super();\n        this.setStrokeColor('black')\n            .setFillColor('black')\n            .setStrokeWidth(2)\n            .showArrow(1, 1);\n    }\n}\n\nexport class HVector extends Vector {\n    setLabel(label) {\n        if (typeof label === 'string')\n            label = new Text()\n                .setPosition(this.getCenterPoint())\n                .setLabel(label)\n                .setOffset([0, -6])\n                .setFontStyle('');\n        return super.setLabel(label);\n    }\n\n    setLength(l) {\n        return (l > 0) ?\n            this.lineTo(['0D', l]) :\n            this.lineTo(['180D', -l])\n    }\n}"]},"metadata":{},"sourceType":"module"}